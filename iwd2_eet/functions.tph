// *** Functions for internal use ***

// To determine game types more easily
OUTER_SET GAME_IS_BGEE = (GAME_IS ~bgee~ AND NOT GAME_INCLUDES ~sod~) ? 1 : 0
OUTER_SET GAME_IS_SOD = (GAME_IS ~bgee~ AND GAME_INCLUDES ~sod~) ? 1 : 0
OUTER_SET GAME_IS_BG2EE = (GAME_IS ~bg2ee~) ? 1 : 0
OUTER_SET GAME_IS_IWDEE = (GAME_IS ~iwdee~) ? 1 : 0
OUTER_SET GAME_IS_EET = (GAME_IS ~eet~) ? 1 : 0
OUTER_SET GAME_IS_EET_IWD = (GAME_IS ~eet~ AND FILE_EXISTS_IN_GAME ~id1000.are~) ? 1 : 0
OUTER_SET SPELL_REV = (MOD_IS_INSTALLED ~setup-spell_rev.tp2~ 0) ? 1 : 0


/**
 * Converts any decimal number into a hexadecimal number
 */
DEFINE_ACTION_FUNCTION TO_HEX_NUMBER
INT_VAR
  value     = 0   // the decimal number
  minDigits = 1   // min. number of digits in return value (not counting sign)
  prefix    = 0   // whether to return number with "0x" prefix
RET
  hexNumber       // returned as string without prefix
BEGIN
  ACTION_IF (minDigits < 1) BEGIN OUTER_SET minDigits = 1 END
  ACTION_IF (minDigits > 8) BEGIN OUTER_SET minDigits = 8 END
  OUTER_TEXT_SPRINT hexNumber ~~
  ACTION_DEFINE_ARRAY digit BEGIN ~0~ ~1~ ~2~ ~3~ ~4~ ~5~ ~6~ ~7~ ~8~ ~9~ ~a~ ~b~ ~c~ ~d~ ~e~ ~f~ END

  ACTION_IF (value < 0) BEGIN
    OUTER_SET signed = 1
    OUTER_SET value = 0 - value
  END ELSE BEGIN
    OUTER_SET signed = 0
  END

  OUTER_WHILE (value != 0) BEGIN
    OUTER_SET curDigit = value BAND 0xf
    OUTER_SET value = value BLSR 4
    OUTER_TEXT_SPRINT hexDigit $EVAL digit(~%curDigit%~)
    OUTER_TEXT_SPRINT hexNumber ~%hexDigit%%hexNumber%~
  END

  OUTER_WHILE (STRING_LENGTH ~%hexNumber%~ < minDigits) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~0%hexNumber%~
  END

  ACTION_IF (prefix) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~0x%hexNumber%~
  END

  ACTION_IF (signed) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~-%hexNumber%~
  END
END

DEFINE_PATCH_FUNCTION TO_HEX_NUMBER
INT_VAR
  value     = 0
  minDigits = 1
  prefix    = 0
RET
  hexNumber
BEGIN
  INNER_ACTION BEGIN
    LAF TO_HEX_NUMBER INT_VAR value = value minDigits = minDigits prefix = prefix RET hexNumber END
  END
END


/**
 * Converts a hexadecimal value back into a decimal number.
 * STR_VAR hexNumber  A string containing a hexadecimal number without prefix.
 * RET value          The resulting decimal number as int value. Returns -1 on error.
 */
DEFINE_ACTION_FUNCTION TO_DEC_NUMBER
STR_VAR
  hexNumber  = ~~
RET
  value
BEGIN
  OUTER_SET value = "-1"

  ACTION_IF (~%hexNumber%~ STRING_EQUAL ~~) BEGIN
    OUTER_SET value = 0
  END ELSE BEGIN
    // checking for sign
    ACTION_IF (~%hexNumber%~ STRING_MATCHES_REGEXP ~-.+~ = 0) BEGIN
      OUTER_SET signed = 1
      OUTER_PATCH_SAVE hexNumber ~%hexNumber%~ BEGIN REPLACE_TEXTUALLY ~^-~ ~~ END
    END ELSE BEGIN
      OUTER_SET signed = 0
    END

    // checking for prefix
    ACTION_IF (~%hexNumber%~ STRING_MATCHES_REGEXP ~^0[xX].+~ = 0) BEGIN
      OUTER_PATCH_SAVE hexNumber ~%hexNumber%~ BEGIN REPLACE_TEXTUALLY ~^0[xX]~ ~~ END
    END

    // converting number
    OUTER_SET curValue = 0
    OUTER_SET scale = 1
    OUTER_SET strlen = STRING_LENGTH ~%hexNumber%~
    OUTER_FOR (idx = strlen - 1; idx >= 0; --idx) BEGIN
      OUTER_PATCH ~%hexNumber%~ BEGIN READ_BYTE idx hexDigit END
      OUTER_SET hexDigit = hexDigit BAND 0xff
      ACTION_IF (hexDigit >= 48 AND hexDigit <= 57) BEGIN // 0..9
        OUTER_SET digit = hexDigit - 48
      END ELSE ACTION_IF (hexDigit >= 65 AND hexDigit <= 70) BEGIN  // A..F
        OUTER_SET digit = hexDigit - 55
      END ELSE ACTION_IF (hexDigit >= 97 AND hexDigit <= 102) BEGIN // a..f
        OUTER_SET digit = hexDigit - 87
      END ELSE BEGIN
        OUTER_SET digit = 0
      END
      OUTER_SET curValue += digit*scale
      OUTER_SET scale = scale BLSL 4
    END

    ACTION_IF (signed) BEGIN
      OUTER_SET curValue = 0 - curValue
    END

    OUTER_SET value = curValue
  END
END

DEFINE_PATCH_FUNCTION TO_DEC_NUMBER
STR_VAR
  hexNumber  = ~~
RET
  value
BEGIN
  INNER_ACTION BEGIN
    LAF TO_DEC_NUMBER STR_VAR hexNumber = EVAL ~%hexNumber%~ RET value END
  END
END


/**
 * Returns a non-zero value in "patched" if the game has been patched to v2.0 or higher.
 */
DEFINE_ACTION_FUNCTION IS_PATCHED_V2
RET patched
BEGIN
  OUTER_SET patched = (FILE_EXISTS ~engine.lua~ AND FILE_EXISTS_IN_GAME ~wmpflag.ids~) ? 1 : 0
END

DEFINE_PATCH_FUNCTION IS_PATCHED_V2
RET patched
BEGIN
  INNER_ACTION BEGIN LAF IS_PATCHED_V2 RET patched END END
END


/**
 * Adds a new entry to a specified IDS file and returns its IDS value.
 * 
 * INT_VAR minValue       Minimum IDS value to consider. (Default: 0)
 * INT_VAR maxValue       Maximum IDS value to consider. (Default: 255)
 * INT_VAR preferredValue Try this IDS value first if available. (Default: unset)
 * INT_VAR hexadecimal    Set to nonzero to add IDS value in hexadecimal notation. (Default: 0)
 * STR_VAR idsFile        The IDS file to add the entry to.
 * STR_VAR identifier     The identifier name for the IDS value. Must not contain whitespace.
 * RET value              The IDS value if entry has been added successfully. -1 if entry could not be added.
 */
DEFINE_ACTION_FUNCTION ADD_IDS_ENTRY
INT_VAR
  minValue        = 0
  maxValue        = 255
  preferredValue  = "-1"
  hexadecimal     = 0
STR_VAR
  idsFile         = ""
  identifier      = ""
RET
  value
BEGIN
  OUTER_SET value = "-1"

  ACTION_IF (minValue < 0) BEGIN OUTER_SET minValue = 0 END
  ACTION_IF (maxValue < minValue) BEGIN OUTER_SET maxValue = minValue END

  ACTION_IF (~%idsFile%~ STRING_MATCHES_REGEXP ~.+\..+~ = 0) BEGIN
    OUTER_PATCH_SAVE idsFile ~%idsFile%~ BEGIN REPLACE_TEXTUALLY ~\(.+\)\.[^.]+~ ~\1~ END
  END

  ACTION_IF (FILE_EXISTS_IN_GAME ~%idsFile%.ids~) BEGIN
    // Try preferred value first
    OUTER_PATCH ~~ BEGIN
      PATCH_IF (preferredValue >= minValue AND preferredValue <= maxValue) BEGIN
        LOOKUP_IDS_SYMBOL_OF_INT retVal ~%idsFile%~ preferredValue
        PATCH_IF (~%retVal%~ STRING_EQUAL ~%preferredValue%~) BEGIN
          SET value = preferredValue
        END
      END
    END
    
    // Looking for available IDS slot
    ACTION_IF (value = "-1") BEGIN
      OUTER_PATCH ~~ BEGIN
        FOR (v = minValue; v <= maxValue; v += 1) BEGIN
          LOOKUP_IDS_SYMBOL_OF_INT retVal ~%idsFile%~ v
          PATCH_IF (~%retVal%~ STRING_EQUAL ~%v%~) BEGIN
            SET value = v
            SET v = maxValue + 1
          END
        END
      END
    END

    // Falling back to preferred value if no free slot found
    ACTION_IF (value = "-1" AND preferredValue >= minValue AND preferredValue <= maxValue) BEGIN
      OUTER_SET value = preferredValue
    END

    // Adding new entry
    ACTION_IF (value != "-1") BEGIN
      ACTION_IF (hexadecimal) BEGIN
        LAF TO_HEX_NUMBER INT_VAR value = value RET hexNumber END
        OUTER_TEXT_SPRINT idsValue ~0x%hexNumber%~
      END ELSE BEGIN
        OUTER_TEXT_SPRINT idsValue ~%value%~
      END

      APPEND ~%idsFile%.ids~ ~%idsValue% %identifier%~ UNLESS ~%identifier%~
      OUTER_SET value = IDS_OF_SYMBOL (~%idsFile%~ ~%identifier%~)
      ACTION_IF (value < minValue OR value > maxValue) BEGIN
        OUTER_SET value = "-1"
      END
    END
  END
END

/* ADD_SPLPROT_ENTRY */
DEFINE_ACTION_FUNCTION ADD_SPLPROT_ENTRY
	INT_VAR
		stat_hex    = 1
		value_hex   = 0
		add_number  = 1
	STR_VAR
		label       = ~~
		definition  = ~~
	RET
		index
		exists
		label1
BEGIN
	OUTER_SET index  = "-1"
	OUTER_SET exists =   0
	ACTION_IF (NOT ~%definition%~ STR_EQ ~~) BEGIN
		//extract definition
		OUTER_SPRINT ~stat~ ~~
		OUTER_SPRINT ~value~ ~~
		OUTER_SPRINT ~rel~ ~~
		OUTER_INNER_PATCH_SAVE definition ~%definition%~ BEGIN
			REPLACE_TEXTUALLY ~[ %TAB%]~ ~*~
			SET lng  = BUFFER_LENGTH
			SET true = 1
			SET cmp  = 0
			FOR ( i = 0 ; i < lng ; ++i ) BEGIN
				READ_ASCII i z (1)
				PATCH_IF ( ~%z%~ STR_CMP ~*~ ) BEGIN
					PATCH_IF ( true = 1 ) BEGIN
						PATCH_MATCH cmp WITH
							0 BEGIN SPRINT ~stat~  ~%stat%%z%~ END
							1 BEGIN SPRINT ~value~ ~%value%%z%~ END
							2 BEGIN SPRINT ~rel~   ~%rel%%z%~ END
						DEFAULT
						END
					END ELSE BEGIN
						SET true = 1
						SET cmp = cmp + 1
						PATCH_MATCH cmp WITH
							0 BEGIN SPRINT ~stat~  ~%stat%%z%~ END
							1 BEGIN SPRINT ~value~ ~%value%%z%~ END
							2 BEGIN SPRINT ~rel~   ~%rel%%z%~ END
						DEFAULT
						END
					END
				END ELSE BEGIN
					SET true = 0
				END
			END
		END
		OUTER_SET stat  =  ~%stat%~
		OUTER_SET value = ~%value%~
		OUTER_SET rel   =   ~%rel%~
		COPY_EXISTING ~splprot.2da~ ~override~
			COUNT_2DA_ROWS 4 table
			//find existing entry
			FOR ( i = 0 ; i < table ; ++i ) BEGIN
				SET true = 0
				READ_2DA_ENTRY i 0 4 label1
				READ_2DA_ENTRY i 1 4 stat1
				PATCH_IF ( IS_AN_INT ~stat1~ )  AND ( stat = stat1 )   BEGIN SET true = true + 1 END
				READ_2DA_ENTRY i 2 4 value1
				PATCH_IF ( IS_AN_INT ~value1~ ) AND ( value = value1 ) BEGIN SET true = true + 1 END
				READ_2DA_ENTRY i 3 4 rel1
				PATCH_IF ( IS_AN_INT ~rel1~ )   AND ( rel = rel1 )     BEGIN SET true = true + 1 END
				PATCH_IF ( true = 3 ) BEGIN
					SET index = i
					SET exists = 1
					SET i = table
					TEXT_SPRINT ~label1~ ~%label1%	%stat1%	%value1%	%rel1%~
				END
			END
			//add_new_string to empty
			PATCH_IF ( index < 0 ) BEGIN
				SET trueex = 0
				FOR ( i = 0 ; i < table ; ++i ) BEGIN
					SET true = 0
					PATCH_IF NOT trueex BEGIN
						READ_2DA_ENTRY i 1 4 stat1
						PATCH_IF ( ~%stat1%~  STR_EQ ~*~ ) BEGIN SET true = true + 1 END
						READ_2DA_ENTRY i 1 4 value1
						PATCH_IF ( ~%value1%~ STR_EQ ~*~ ) BEGIN SET true = true + 1 END
						READ_2DA_ENTRY i 1 4 rel1
						PATCH_IF ( ~%rel1%~   STR_EQ ~*~ ) BEGIN SET true = true + 1 END
						PATCH_IF ( true = 3 ) BEGIN
							SET index = i
							SET i = table
							PATCH_IF add_number BEGIN SPRINT nbr ~%index%_~ END ELSE BEGIN SPRINT nbr ~~ END
							TEXT_SPRINT ~label1~ ~%nbr%%label%	%stat%	%value%	%rel%~
							SET_2DA_ENTRY index 0 4 ~%nbr%%label%~
							SET_2DA_ENTRY index 1 4 ~%stat%~
							SET_2DA_ENTRY index 2 4 ~%value%~
							SET_2DA_ENTRY index 3 4 ~%rel%~
						END
					END
				END
			END
			//add_new_string
			PATCH_IF ( index < 0 ) BEGIN
				SET index = table
				PATCH_IF (~%label%~ STR_EQ ~~) BEGIN TEXT_SPRINT label ~%index%~ END
				PATCH_IF ( stat >= 0 ) AND ( stat_hex = 1 ) BEGIN
					LPF TO_HEX_NUMBER INT_VAR value=stat minDigits=3 prefix=1 RET stat=hexNumber END
				END
				PATCH_IF ( value >= 0 ) AND ( value_hex = 1 ) BEGIN
					LPF TO_HEX_NUMBER INT_VAR value=value prefix=1 RET value=hexNumber END
				END
				PATCH_IF add_number BEGIN SPRINT nbr ~%index%_~ END ELSE BEGIN SPRINT nbr ~~ END
				TEXT_SPRINT ~label1~ ~%nbr%%label%	%stat%	%value%	%rel%~
				INSERT_2DA_ROW index 4 ~%label1%~
				PRETTY_PRINT_2DA
			END
			BUT_ONLY_IF_IT_CHANGES
			IF_EXISTS
	END
END

/* FC_ADD_CLAB_DATA */
DEFINE_ACTION_FUNCTION FC_ADD_CLAB_DATA
	INT_VAR
		level = 1
		top   = 1
	STR_VAR
		file  = ""
		label = ""
		abil  = ""
		type  = "AP_"
	RET
		done
BEGIN
	OUTER_SET done = 0
	OUTER_SET exists = 0
	ACTION_IF ( ~%file%~ STR_CMP ~~ ) AND
	          ( ~%abil%~ STR_CMP ~~ ) AND
	          ( level > 0 ) AND
	          ( STRING_LENGTH ~%abil%~ < 9 ) BEGIN
		ACTION_IF NOT FILE_EXISTS_IN_GAME ~%file%.2da~ BEGIN
			OUTER_SPRINT header ~	~
			OUTER_SPRINT ability ~ABILITY1~
			OUTER_FOR ( i = 1 ; i < 51 ; ++i ) BEGIN
				OUTER_SPRINT header ~%header%	%i%~
				OUTER_SPRINT ability ~%ability%	****~
			END
<<<<<<<< .../clabfile.2da
2DA V1.0
****
%header%
%ability%
>>>>>>>>
			COPY ~.../clabfile.2da~ ~override/%file%.2da~ EVALUATE_BUFFER PRETTY_PRINT_2DA
		END
		COPY_EXISTING ~%file%.2da~ ~override~
			COUNT_2DA_COLS cols
			SET rows = 0
			PATCH_IF ( level < cols ) BEGIN exists = 1 END
			PATCH_IF exists BEGIN
				COUNT_2DA_ROWS cols rows
				SET line = 0
				PATCH_IF ( rows > 0 ) BEGIN
					FOR ( i = 0 ; i < rows ; ++i ) BEGIN
						READ_2DA_ENTRY i 0 cols lbl
						READ_2DA_ENTRY i level cols value
						PATCH_IF NOT done BEGIN
							PATCH_IF ( ~%label%~ STR_EQ ~~ ) BEGIN
								PATCH_IF ( ~%value%~ STR_EQ ~****~ ) BEGIN
									SET_2DA_ENTRY i level cols ~%type%%abil%~
									SET done = 1
									SET i = rows
								END
							END ELSE BEGIN
								PATCH_IF ( ~%label%~ STR_EQ ~%lbl%~ ) BEGIN
									PATCH_IF ( ~%value%~ STR_EQ ~****~ ) BEGIN
										SET_2DA_ENTRY i level cols ~%type%%abil%~
										SET done = 1
										SET i = rows
									END
								END
							END
						END
					END
				END
				SET rows = rows + 1
				PATCH_IF ( ~%label%~ STR_EQ ~~ ) BEGIN SPRINT label ~ABILITY%rows%~ END
				FOR ( i = 1 ; i < cols ; ++i ) BEGIN
					PATCH_IF ( i = level ) BEGIN SPRINT value ~%type%%abil%~
					END ELSE BEGIN SPRINT value ~****~ END
					SPRINT label ~%label%	%value%~
				END
				PATCH_IF top BEGIN SET pos = 0 END ELSE BEGIN SET pos = rows END
				INSERT_2DA_ROW 0 cols ~%label%~
				SET done = 1
			END
			BUT_ONLY_IF_IT_CHANGES
	END
END


// Animation slots reserved by vanilla or mod-added game creatures (in hexadecimal format)
// Supported mods:
// - Bearwalker + extended Werebear animation
// - Pack Mule
<<<<<<<< .../inlined/creature/animation/slots.txt
"0410" "1000" "1003" "1004" "1100" "1101" "1102" "1103" "1104" "1105" "1200" "1201" "1202" "1203" "1204" "1205" "1206" "1207" "1208" "1300" "2000" "2100" "2200" "2300" "3000" "3001" "4000" "4001" "4002" "4010" "4012" "4100" "4101" "4102" "4110" "4112" "4200" "4300" "4400" "4410" "4500" "4600" "4700" "4710" "4800" "5000" "5001" "5002" "5003" "5010" "5011" "5012" "5013" "5100" "5101" "5102" "5103" "5110" "5111" "5112" "5113" "5200" "5201" "5202" "5210" "5211" "5212" "5300" "5301" "5302" "5303" "5310" "5311" "5312" "5313" "6000" "6001" "6002" "6003" "6004" "6005" "6010" "6011" "6012" "6013" "6014" "6015" "6100" "6101" "6102" "6103" "6104" "6105" "6110" "6111" "6112" "6113" "6114" "6115" "6200" "6201" "6202" "6204" "6205" "6210" "6211" "6212" "6214" "6215" "6300" "6301" "6302" "6303" "6304" "6305" "6310" "6311" "6312" "6313" "6314" "6315" "6400" "6401" "6402" "6403" "6404" "6405" "6406" "6500" "6510" "6621" "7000" "7001" "7100" "7101" "7200" "7201" "7202" "7203" "7300" "7301" "7302" "7310" "7311" "7312" "7313" "7314" "7320" "7321" "7400" "7401" "7402" "7500" "7501" "7600" "7601" "7602" "7603" "7604" "7700" "7701" "7702" "7703" "7800" "7801" "7802" "7900" "7901" "7902" "7903" "7904" "7a00" "7a01" "7a02" "7a03" "7a04" "7b00" "7b01" "7b02" "7b03" "7b04" "7b05" "7b06" "7c00" "7c01" "7d00" "7d01" "7d02" "7d03" "7d04" "7d05" "7d06" "7d07" "7d08" "7e00" "7e01" "7f00" "7f01" "7f02" "7f03" "7f04" "7f05" "7f06" "7f07" "7f08" "7f09" "7f0a" "7f0b" "7f0c" "7f0d" "7f0e" "7f0f" "7f10" "7f11" "7f12" "7f13" "7f14" "7f15" "7f16" "7f17" "7f18" "7f19" "7f20" "7f21" "7f22" "7f23" "7f24" "7f27" "7f28" "7f29" "7f2a" "7f2b" "7f2c" "7f2d" "7f2e" "7f2f" "7f30" "7f31" "7f32" "7f33" "7f34" "7f35" "7f36" "7f37" "7f38" "7f39" "7f3a" "7f3b" "7f3c" "7f3d" "7f3e" "7f3f" "7f40" "7f41" "7f42" "7f43" "7f44" "7f45" "7f46" "7f47" "7f48" "7f49" "7f4a" "7f4b" "7f4c" "7f4d" "7f4e" "7f4f" "7f50" "7f51" "7f52" "7f53" "7f54" "7f55" "7f56" "7f57" "7f58" "7f59" "7f5a" "7f5b" "7f5c" "7f5d" "7f5e" "7f5f" "7f60" "7f61" "7f62" "8000" "8100" "8200" "9000" "a000" "a100" "a200" "a201" "a202" "b000" "b100" "b200" "b210" "b300" "b310" "b400" "b410" "b500" "b510" "b600" "b610" "b700" "c000" "c100" "c200" "c300" "c400" "c500" "c600" "c610" "c700" "c710" "c800" "c810" "c900" "c910" "ca00" "ca10" "cb00" "cc00" "cc01" "cc02" "cc04" "d000" "d100" "d200" "d300" "d400" "e000" "e010" "e020" "e040" "e050" "e060" "e070" "e080" "e090" "e0a0" "e0b0" "e0c0" "e0d0" "e0e0" "e0f0" "e0f1" "e0f2" "e200" "e210" "e220" "e230" "e240" "e241" "e242" "e243" "e244" "e245" "e246" "e247" "e248" "e249" "e24a" "e24b" "e24c" "e24d" "e24e" "e24f" "e250" "e251" "e252" "e253" "e254" "e255" "e256" "e257" "e258" "e259" "e25a" "e25b" "e25c" "e25d" "e25e" "e25f" "e260" "e261" "e262" "e263" "e264" "e265" "e266" "e267" "e26a" "e26b" "e26d" "e26e" "e26f" "e270" "e271" "e272" "e273" "e274" "e276" "e279" "e27d" "e27e" "e27f" "e280" "e281" "e282" "e283" "e288" "e289" "e28a" "e28b" "e28c" "e28d" "e28e" "e28f" "e290" "e291" "e292" "e293" "e294" "e300" "e310" "e320" "e330" "e400" "e410" "e420" "e430" "e440" "e441" "e442" "e443" "e444" "e500" "e510" "e520" "e600" "e610" "e6fe" "e700" "e710" "e720" "e800" "e810" "e820" "e830" "e840" "e900" "e910" "ea00" "ea10" "ea20" "eb00" "eb10" "eb20" "ec00" "ec10" "ec20" "ed00" "ed10" "ed20" "ee00" "ee10" "ef10"
>>>>>>>>
OUTER_TEXT_SPRINT animationSlotsPath ".../inlined/creature/animation/slots.txt"

/**
 * Returns the first free creature animation slot in the range defined by slotMin and slotMax.
 * INT_VAR slotMin    Lowest available creature animation slot for the animation.
 * INT_VAR slotMax    Highest available creature animation slot for the animation.
 * INT_VAR slotSteps  How many slots to skip after each iteration, starting from slotMin.
 *                    Setting this parameter is useful if compatible animation slots are always 
 *                    a fixed distance apart (e.g. at a distance of 0x10 each)
 * RET slot           A free animation slot. Returns -1 if none found.
 */
DEFINE_ACTION_FUNCTION FIND_FREE_ANIM_SLOT
INT_VAR
  slotMin   = 0
  slotMax   = (slotMin BAND 0xf000) + 0x1000
  slotSteps = 1
RET
  slot
BEGIN
  OUTER_SET slot = "-1"
  ACTION_IF (slotSteps < 1) BEGIN OUTER_SET slotSteps = 1 END
  ACTION_IF (slotMin < 0) BEGIN OUTER_SET slotMin = 0 END
  ACTION_IF (slotMax < 0) BEGIN OUTER_SET slotMax = 0 END
  ACTION_IF (slotMax < slotMin) BEGIN
    OUTER_SET tmp = slotMin
    OUTER_SET slotMin = slotMax
    OUTER_SET slotMax = tmp
  END

  // animslots.txt contains reserved creature animation slots
  COPY - ~%animationSlotsPath%~ ~%animationSlotsPath%~
    READ_ASCII 0 slotList (SOURCE_SIZE)
    FOR (idx = slotMin; idx < slotMax; idx += slotSteps) BEGIN
      LOOKUP_IDS_SYMBOL_OF_INT name ~animate~ idx
      PATCH_IF (~%name%~ STRING_EQUAL ~%idx%~) BEGIN
        LPF TO_HEX_NUMBER INT_VAR value = idx minDigits = 4 RET hexNumber END
        PATCH_IF (NOT FILE_EXISTS_IN_GAME ~%hexNumber%.ini~ AND 
                  ~%slotList%~ STRING_CONTAINS_REGEXP ~"%hexNumber%"~ != 0) BEGIN
          SET slot = idx
          SET idx = slotMax
        END
      END
    END
END

DEFINE_PATCH_FUNCTION FIND_FREE_ANIM_SLOT
INT_VAR
  slotMin   = 0
  slotMax   = (slotMin BAND 0xf000) + 0x1000
  slotSteps = 1
RET
  slot
BEGIN
  INNER_ACTION BEGIN
    LAF FIND_FREE_ANIM_SLOT INT_VAR slotMin = slotMin slotMax = slotMax slotSteps = slotSteps RET slot END
  END
END


// Work-around for a buggy WeiDU function
DEFINE_PATCH_FUNCTION ADD_SPELL_EFFECT
  INT_VAR opcode = 0
          target = 0
          timing = 0
          parameter1 = 0
          parameter2 = 0
          power = 0
          resist_dispel = 0
          duration = 0
          probability1 = 100
          probability2 = 0
          dicenumber = 0
          dicesize = 0
          savingthrow = 0
          savebonus = 0
          header = 0
          insert_point = "-1"
          special = 0
          ___#special = special   // fixed spelling error
  STR_VAR resource = ~~
BEGIN
  LAUNCH_PATCH_MACRO ~ADD_SPELL_EFFECT~
END


/**
 * Creates a spell which contains all externalized wild surge effects.
 * STR_VAR resName    Name of the resulting spell (without extension).
 * STR_VAR resDefault Name of the default spell when no externalized resource is available or spell is cast successfully.
 */
DEFINE_ACTION_FUNCTION CREATE_WILD_SURGE_SPELL
STR_VAR
  resName = ~~
  resDefault = ~~
BEGIN
  ACTION_IF (NOT ~%resName%~ STRING_EQUAL ~~) BEGIN
    // retrieving wild surge resources and strrefs
    COPY_EXISTING - ~wildmag.2da~ ~override~
      COUNT_2DA_COLS numCols
      COUNT_2DA_ROWS numCols numRows
      PATCH_IF (numRows > 100) BEGIN numRows = 100 END
      FOR (idx = 0; idx < numRows; ++idx) BEGIN
        READ_2DA_ENTRY idx 1 numCols res
        PATCH_IF (NOT ~%res%~ STRING_EQUAL ~*~ AND FILE_EXISTS_IN_GAME ~%res%.spl~) BEGIN
          TEXT_SPRINT $EVAL resRef(~%idx%~) ~%res%~
        END ELSE BEGIN
          TEXT_SPRINT $EVAL resRef(~%idx%~) ~%resDefault%~
        END

        READ_2DA_ENTRY idx 2 numCols str
        PATCH_IF (IS_AN_INT ~%str%~) BEGIN
          SET $EVAL strref(~%idx%~) = str
        END ELSE BEGIN
          SET $EVAL strref(~%idx%~) = "-1"
        END
      END

    // applying wild surge effects to target spell
    CREATE SPL ~%resName%~
      WRITE_SHORT 0x1c 4      // Spell type = innate
      WRITE_LONG 0x34 1       // Spell level
      WRITE_LONG 0x64 0x72    // abilities offset
      WRITE_SHORT 0x68 1      // # abilities
      WRITE_LONG 0x6a 0x9a    // effects offset
      INSERT_BYTES 0x72 0x28  // space for ability
      // creating ability structure
      WRITE_SHORT 0x72 1      // type = melee
      WRITE_SHORT 0x74 4      // location = innate
      WRITE_BYTE 0x7e 1       // target = living creature
      WRITE_SHORT 0x80 1      // range
      WRITE_SHORT 0x82 1      // min. level
      WRITE_SHORT 0x8e 1      // damage type
      WRITE_SHORT 0x94 1      // # charges
      WRITE_SHORT 0x98 1      // projectile = none

      FOR (idx = 0; idx < numRows; ++idx) BEGIN
        TEXT_SPRINT res $EVAL resRef(~%idx%~)
        SET str = $EVAL strref(~%idx%~)
        LPF ADD_SPELL_EFFECT
        INT_VAR
          opcode = 146      // Cast spell
          target = 2        // Preset target
          parameter2 = 1    // Cast instantly (ignore level)
          timing = 1        // Instant/Permanent until death
          probability1 = idx
          probability2 = idx
        STR_VAR
          resource = EVAL "%res%"
        END

        LPF ADD_SPELL_EFFECT
        INT_VAR
          opcode = 139      // Display string
          target = 2        // Preset target
          parameter1 = str
          timing = 1        // Instant/Permanent until death
          probability1 = idx
          probability2 = idx
        END
      END
  END
END


/**
 * Adds a new random treasure entry to RNDTRES.2DA. The entry is generated with a specified percentage for the given item.
 * This function also creates a treasure placeholder item if needed.
 * INT_VAR chance   The chance of the item to be generated (in percent).
 * STR_VAR treasure The resource name of the placeholder treasure item without extension
 * STR_VAR defItem  Default item for the columns not defined by chance.
 * STR_VAR item     The resource name of the item to generate by the random treasure item.
 * RET success      Returns non-zero on success and zero on fail.
 */
DEFINE_ACTION_FUNCTION DEFINE_RANDOM_TREASURE
INT_VAR
  chance    = 100
STR_VAR
  treasure  = ~~
  defItem   = ~A7!EMPTY~
  item      = ~~
RET
  success
BEGIN
  LAF DEFINE_RANDOM_TREASURE_EX INT_VAR chance_0 = chance STR_VAR treasure = EVAL ~%treasure%~ defItem = EVAL ~%defItem%~ item_0 = EVAL ~%item%~ RET success END
END


/**
 * Adds a new random treasure entry to RNDTRES.2DA. The entry is generated with the specified percentages of the given items.
 * This function also creates a treasure placeholder item if needed.
 * INT_VAR chance_x The chance of the associated item to be generated (in percent). x must be a sequential number, starting at 0.
 *                  Important: The sum of chances must not be greater than 100%.
 * STR_VAR treasure The resource name of the placeholder treasure item without extension
 * STR_VAR defItem  Default item for the columns not defined by chance_x.
 * STR_VAR item_x   The resource names of the items to generate by the random treasure item. x must be a sequential number, starting at 0.
 * RET success      Returns non-zero on success and zero on fail.
 */
DEFINE_ACTION_FUNCTION DEFINE_RANDOM_TREASURE_EX
INT_VAR
  // chance_0, chance_1, ...
STR_VAR
  treasure  = ~~
  defItem   = ~A7!EMPTY~
  // item_0, item_1, ...
RET
  success
BEGIN
  OUTER_SET success = 0
  ACTION_IF (FILE_EXISTS_IN_GAME ~rndtres.2da~ AND
             NOT ~%treasure%~ STRING_EQUAL ~~ AND
             STRING_LENGTH ~%treasure%~ <= 8) BEGIN
    // validating input
    OUTER_SET numItems = 0
    OUTER_SET failed = 0
    OUTER_SET sumChance = 0
    OUTER_FOR (idx = 0; idx < 100; ++idx) BEGIN
      ACTION_IF (VARIABLE_IS_SET $EVAL chance(~%idx%~) AND VARIABLE_IS_SET $EVAL item(~%idx%~)) BEGIN
        ACTION_IF (sumChance > 100) BEGIN OUTER_SET failed = 1 OUTER_SET idx = 100 END
        OUTER_SET valChance = $EVAL chance(~%idx%~)
        ACTION_IF (valChance < 0) BEGIN OUTER_SET $EVAL chance(~%idx%~) = 0 END
        ACTION_IF (valChance > 100) BEGIN OUTER_SET $EVAL chance(~%idx%~) = 100 END
        OUTER_SET sumChance += valChance

        OUTER_TEXT_SPRINT name $EVAL item(~%idx%~)
        ACTION_IF (~%name%~ STRING_EQUAL ~~ OR STRING_LENGTH ~%name%~ > 8) BEGIN OUTER_SET failed = 1 OUTER_SET idx = 100 END
      END ELSE BEGIN
        OUTER_SET numItems = idx
        OUTER_SET idx = 100
      END
    END
    ACTION_IF (numItems = 0) BEGIN OUTER_SET failed = 1 END

    ACTION_IF (failed = 0) BEGIN
      COPY_EXISTING ~rndtres.2da~ ~override~
        COUNT_2DA_COLS numCols
        COUNT_2DA_ROWS numCols numRows

        // check if entry already exists
        FOR (idx = 0; idx < numRows; ++idx) BEGIN
          READ_2DA_ENTRY idx 0 numCols name
          PATCH_IF (~%name%~ STRING_EQUAL_CASE ~%treasure%~) BEGIN
            SET failed = 1
            SET idx = numRows
          END
        END

        PATCH_IF (failed = 0) BEGIN
          // generating entry name
          TEXT_SPRINT newEntry ~%treasure%~
          FOR (idx = 9 - (STRING_LENGTH ~%treasure%~); idx > 0; --idx) BEGIN TEXT_SPRINT newEntry ~%newEntry% ~ END

          SET numCols -= 1  // exclude treasure name column
          SET sumItems = 0
          FOR (idxItem = 0; idxItem < numItems; ++idxItem) BEGIN
            // calculating item count
            SET itmChance = $EVAL chance(~%idxItem%~)
            TEXT_SPRINT itmName $EVAL item(~%idxItem%~)
            SET itmCount = (itmChance * numCols) / 100
            PATCH_IF (itmChance > 0 AND itmCount = 0) BEGIN SET itmCount += 1 END
            PATCH_IF (itmChance < 100 AND itmCount = numCols) BEGIN SET itmCount -= 1 END
            SET sumItems += itmCount
            PATCH_IF (sumItems <= numCols) BEGIN
              // adding item to entry
              FOR (col = 0; col < itmCount; ++col) BEGIN
                TEXT_SPRINT newEntry ~%newEntry%%itmName%~
                FOR (idx = 9 - (STRING_LENGTH ~%itmName%~); idx > 0; --idx) BEGIN TEXT_SPRINT newEntry ~%newEntry% ~ END
              END
            END ELSE BEGIN
              SET idxItem = numItems
            END
          END

          // adding empty items
          FOR (idx = 9 - (STRING_LENGTH ~%defItem%~); idx > 0; --idx) BEGIN TEXT_SPRINT defItem ~%defItem% ~ END
          FOR (col = sumItems; col < numCols; ++col) BEGIN
            TEXT_SPRINT newEntry ~%newEntry%%defItem%~
          END

          // adding entry to 2DA
          INSERT_2DA_ROW numRows (numCols + 1) ~%newEntry%~
        END

      ACTION_IF (failed = 0) BEGIN
        ACTION_IF (NOT FILE_EXISTS ~%treasure%.itm~ AND FILE_EXISTS_IN_GAME ~rndtre01.itm~) BEGIN
          COPY_EXISTING ~rndtre01.itm~ ~override/%treasure%.itm~
        END
        OUTER_SET success = 1
      END
    END
  END
END


/**
 * Attempts to determine the index of an ARE actor structure.
 * INT_VAR defaultIndex Returned if no actor matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching actor to be returned. (Default: 0)
 * STR_VAR name         Name of actor to find.
 * RET index            The actor index if found, or defaultIndex if not found.
 * RET offset           The offset of the actor structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_ACTOR
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  name = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  READ_LONG 0x54 ofsActors
  READ_SHORT 0x58 numActors
  FOR (idx = 0; idx < numActors; ++idx) BEGIN
    SET curOfs = ofsActors + (idx * 0x110)
    READ_ASCII curOfs curName ( 32 ) NULL
    PATCH_IF (~%curName%~ STRING_EQUAL_CASE ~%name%~) BEGIN
      PATCH_IF (skip <= 0) BEGIN
        SET index = idx
        SET offset = curOfs
        SET idx = numActors
      END ELSE BEGIN
        SET skip -= 1
      END
    END
  END
END

/**
 * Attempts to determine the index of an ARE region structure.
 * INT_VAR defaultIndex Returned if no region matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching region to be returned. (Default: 0)
 * STR_VAR name         Name of region to find.
 * RET index            The region index if found, or defaultIndex if not found.
 * RET offset           The offset of the region structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_REGION
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  name = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  READ_SHORT 0x5a numRegions
  READ_LONG 0x5c ofsRegions
  FOR (idx = 0; idx < numRegions; ++idx) BEGIN
    SET curOfs = ofsRegions + (idx * 0xc4)
    READ_ASCII curOfs curName ( 32 ) NULL
    PATCH_IF (~%curName%~ STRING_EQUAL_CASE ~%name%~) BEGIN
      PATCH_IF (skip <= 0) BEGIN
        SET index = idx
        SET offset = curOfs
        SET idx = numRegions
      END ELSE BEGIN
        SET skip -= 1
      END
    END
  END
END

/**
 * Attempts to determine the index of an ARE container structure.
 * INT_VAR defaultIndex Returned if no container matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching container to be returned. (Default: 0)
 * STR_VAR name         Name of container to find.
 * RET index            The container index if found, or defaultIndex if not found.
 * RET offset           The offset of the container structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_CONTAINER
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  name = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  READ_LONG 0x70 ofsContainers
  READ_SHORT 0x74 numContainers
  FOR (idx = 0; idx < numContainers; ++idx) BEGIN
    SET curOfs = ofsContainers + (idx * 0xc0)
    READ_ASCII curOfs curName ( 32 ) NULL
    PATCH_IF (~%curName%~ STRING_EQUAL_CASE ~%name%~) BEGIN
      PATCH_IF (skip <= 0) BEGIN
        SET index = idx
        SET offset = curOfs
        SET idx = numContainers
      END ELSE BEGIN
        SET skip -= 1
      END
    END
  END
END

/**
 * Attempts to determine the index of an ARE container item structure.
 * INT_VAR defaultIndex Returned if no container matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching container to be returned. (Default: 0)
 * STR_VAR resource     Item resource to find.
 * RET index            The item index if found, or defaultIndex if not found.
 * RET offset           The offset of the item structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_CONTAINER_ITEM
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  resource = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  PATCH_IF (NOT ~%resource%~ STRING_EQUAL ~~) BEGIN
    READ_SHORT 0x76 numItems
    READ_LONG 0x78 ofsItems
    FOR (idx = 0; idx < numItems; ++idx) BEGIN
      SET curOfs = ofsItems + (idx * 0x14)
      READ_ASCII curOfs curRes ( 8 ) NULL
      PATCH_IF (~%curRes%~ STRING_EQUAL_CASE ~%resource%~) BEGIN
        PATCH_IF (skip <= 0) BEGIN
          SET index = idx
          SET offset = curOfs
          SET idx = numItems
        END ELSE BEGIN
          SET skip -= 1
        END
      END
    END
  END
END


/**
 * Distributes items as defined in a 2DA table structure.
 * STR_VAR table  Full path to the item table.
 */
DEFINE_ACTION_FUNCTION DISTRIBUTE_ITEMS
STR_VAR
  table = ~~
BEGIN
  ACTION_IF (FILE_EXISTS ~%table%~) BEGIN
    COPY - ~%table%~ ~%table%~
      EVALUATE_BUFFER
      COUNT_2DA_ROWS 7 numRows
      FOR (idx = 0; idx < numRows; ++idx) BEGIN
        READ_2DA_ENTRY idx 0 7 type
        READ_2DA_ENTRY idx 1 7 res
        READ_2DA_ENTRY idx 2 7 name
        READ_2DA_ENTRY idx 3 7 item
        READ_2DA_ENTRY idx 4 7 count
        READ_2DA_ENTRY idx 5 7 count2
        READ_2DA_ENTRY idx 6 7 count3
        INNER_ACTION BEGIN
          ACTION_IF (~%type%~ STRING_EQUAL_CASE ~ACTOR~) BEGIN
            ACTION_IF (FILE_EXISTS_IN_GAME ~%res%.cre~) BEGIN
              COPY_EXISTING ~%res%.cre~ ~override~
                PATCH_IF (~%name%~ STRING_EQUAL_CASE ~*~) BEGIN TEXT_SPRINT name ~NONE~ END
                ADD_CRE_ITEM ~%item%~ (count) (count2) (count3) ~%name%~ ~INV1 INV2 INV3 INV4 INV5 INV6 INV7 INV8 INV9 INV10 INV11 INV12 INV13 INV14 INV15 INV16 QITEM1 QITEM2 QITEM3 QUIVER1 QUIVER2 QUIVER3 QUIVER4~
              BUT_ONLY
            END
          END ELSE ACTION_IF (~%type%~ STRING_EQUAL_CASE ~STORE~ OR ~%type%~ STRING_EQUAL_CASE ~STORE+~) BEGIN
            ACTION_IF (FILE_EXISTS_IN_GAME ~%res%.sto~) BEGIN
              COPY_EXISTING ~%res%.sto~ ~override~
                TO_UPPER name
                PATCH_MATCH ~%name%~ WITH
                  ~IDENTIFIED~ ~UNSTEALABLE~ ~STOLEN~ ~IDENTIFIED&STOLEN~ ~IDENTIFIED&UNSTEALABLE~
                  BEGIN
                  END
                  ~*~
                  BEGIN
                    TEXT_SPRINT name ~IDENTIFIED~
                  END
                  DEFAULT
                    TEXT_SPRINT name ~NONE~
                END
                PATCH_IF (~%type%~ STRING_EQUAL_CASE ~STORE~) BEGIN
                  ADD_STORE_ITEM ~%item%~ LAST (count2) (count3) (0) ~%name%~ (count)
                END ELSE BEGIN
                  ADD_STORE_ITEM + ~%item%~ LAST (count2) (count3) (0) ~%name%~ (count)
                END
              BUT_ONLY
            END
          END ELSE ACTION_IF (~%type%~ STRING_EQUAL_CASE ~CONTAINER~) BEGIN
            ACTION_IF (FILE_EXISTS_IN_GAME ~%res%.ARE~) BEGIN
              COPY_EXISTING ~%res%.ARE~ ~override~
                INNER_PATCH_SAVE name ~%name%~ BEGIN REPLACE_TEXTUALLY EXACT_MATCH ~*~ ~ ~ END
                LPF ARE_INDEX_OF_CONTAINER STR_VAR name = EVAL ~%name%~ RET index END
                PATCH_IF (index >= 0) BEGIN
                  LPF fj_are_structure
                  INT_VAR
                    fj_con_itm_idx    = index
                    fj_charge0        = count
                    fj_charge1        = count2
                    fj_charge2        = count3
                  STR_VAR
                    fj_structure_type = "itm"
                    fj_name           = EVAL "%item%"
                  END
                END
              BUT_ONLY
            END
          END
        END
      END
  END
END


/**
 * Adds the specified bright tint (opcode 52) to the current CRE resource 
 * unless it has been recolored already.
 */
DEFINE_PATCH_FUNCTION APPLY_GOLEM_TINT_BRIGHT
INT_VAR
  rgb = 0
BEGIN
  READ_ASCII 0 sig (8)
  PATCH_IF (~%sig%~ STRING_EQUAL ~CRE V1.0~) BEGIN
    // checking for existing color effects
    READ_BYTE 0x33 version
    READ_LONG 0x2c4 ofsEffects
    READ_SHORT 0x2c8 numEffects
    SET sizeEffect = (version = 1) ? 0x108 : 0x30
    SET match = 0
    FOR (idx = 0; idx < numEffects; idx += 1) BEGIN
      SET curOfs = ofsEffects + (idx * sizeEffect)
      PATCH_IF (version = 1) BEGIN
        READ_LONG (curOfs + 8) opcode
      END ELSE BEGIN
        READ_SHORT curOfs opcode
      END
      PATCH_IF (opcode = 51 OR opcode = 52) BEGIN
        SET match = 1
        SET idx = numEffects
      END
    END

    // applying effects
    PATCH_IF (NOT match) BEGIN
      // Adding color tint
      LPF ADD_CRE_EFFECT
      INT_VAR
        opcode = 52             // Character tint bright
        timing = 9              // Instant/Permanent
        target = 1              // Self
        parameter1  = rgb
        parameter2  = 2         // Location = Major color
      END
      PATCH_FOR_EACH param2 IN ~9~ ~50~ BEGIN
        // Protecting original color tint
        LPF ADD_CRE_EFFECT
        INT_VAR
          opcode = 101  // Immunity to effect
          timing = 9    // Instant/Permanent
          target = 1    // Self
          parameter2  = param2
        END
      END
    END
  END
END

/**
 * Adds "Stone Golem" color effect to the current CRE resource unless it has 
 * been recolored already.
 */
DEFINE_PATCH_FUNCTION APPLY_STONE_GOLEM_TINT
BEGIN
  // RGB(4,7,7)
  LPF APPLY_GOLEM_TINT_BRIGHT INT_VAR rgb = 0x7070400 END
END

/**
 * Adds "Brain Golem" color effect to the current CRE resource unless it has 
 * been recolored already.
 */
DEFINE_PATCH_FUNCTION APPLY_BRAIN_GOLEM_TINT
BEGIN
  // RGB(14,12,8)
  LPF APPLY_GOLEM_TINT_BRIGHT INT_VAR rgb = 0x080c0e00 END
END


/**
 * Adds an opcode to set a specific spell state to the current creature or spell resource.
 */
DEFINE_PATCH_FUNCTION APPLY_SPELL_STATE
INT_VAR
  splstate  = "-1"
BEGIN
  PATCH_IF (splstate >= 0) BEGIN
    READ_ASCII 0 sig (8)
    PATCH_IF (~%sig%~ STRING_EQUAL ~CRE V1.0~) BEGIN
      LPF ADD_CRE_EFFECT
      INT_VAR
        opcode  = 328     // Set spell state
        timing  = 9       // Instant/Permanent
        target  = 1       // Self
        parameter2  = splstate
        special = 1       // IWD2 mode
      END
    END ELSE PATCH_IF (~%sig%~ STRING_EQUAL ~SPL V1  ~) BEGIN
      LPF ADD_SPELL_EFFECT
      INT_VAR
        opcode  = 328
        timing  = 9       // Instant/Permanent
        target  = 2       // Preset target
        parameter2    = splstate
        resist_dispel = 2
        special = 1       // IWD2 mode
      END
    END
  END
END


/**
 * Removes the specified spell state from the current creature or spell resource.
 */
DEFINE_PATCH_FUNCTION REMOVE_SPELL_STATE
INT_VAR
  splstate = "-1"
BEGIN
  READ_ASCII 0 sig (8)
  PATCH_IF (~%sig%~ STRING_EQUAL ~CRE V1.0~) BEGIN
    LPF ADD_CRE_EFFECT
    INT_VAR
      opcode  = 337     // Remove opcode
      timing  = 9       // Instant/Permanent
      target  = 1       // Self
      parameter1  = splstate
      parameter2  = 328 // Opcode: Set Spell State
    END
  END ELSE PATCH_IF (~%sig%~ STRING_EQUAL ~SPL V1  ~) BEGIN
    LPF ADD_SPELL_EFFECT
    INT_VAR
      opcode  = 337
      timing  = 9       // Instant/Permanent
      target  = 2       // Preset target
      parameter1  = splstate
      parameter2  = 328 // Opcode: Set Spell State
      resist_dispel = 2
    END
  END
END


/**
 * Returns column and row index of the 2DA entry that matches the specified search text of the given 2da file.
 */
DEFINE_PATCH_FUNCTION GET_2DA_ENTRY_OF
INT_VAR
  row_match = "-1"  // neg. value indicates to search all rows
  col_match = "-1"  // neg. value indicates to search all columns
STR_VAR
  file          = ~~  // the 2da filename
  entry_match   = ~~  // search text
RET
  row col
BEGIN
  SET row = "-1"
  SET col = "-1"
  INNER_ACTION BEGIN
    COPY_EXISTING - ~%file%~ ~override~
      COUNT_2DA_COLS numCols
      COUNT_2DA_ROWS numCols numRows
      SET rowOffset = (numCols = 1 || numCols = 2) ? 1 : 0  // to compensate for 2DA headers
      SET rowMin = (row_match < 0) ? 0 : row_match
      SET rowMax = (row_match < 0) ? (numRows - 1) : row_match
      SET colMin = (col_match < 0) ? 0 : col_match
      SET colMax = (col_match < 0) ? (numCols - 1) : col_match
      FOR (curRow = rowMin + rowOffset; curRow <= rowMax; ++curRow) BEGIN
        FOR (curCol = colMin; curCol <= colMax; ++curCol) BEGIN
          READ_2DA_ENTRY curRow curCol numCols value
          PATCH_IF (~%entry_match%~ STR_EQ ~%value%~) BEGIN
            SET row = curRow - rowOffset
            SET col = curCol
            SET curRow = rowMax + 1
            SET curCol = colMax + 1
          END
        END
      END
    IF_EXISTS
  END
END

//BLOCK FC_UPDETE_AREA_OFFSETS
DEFINE_PATCH_FUNCTION FC_UPDETE_AREA_OFFSETS
	INT_VAR
		num = 1
	STR_VAR
		type = actor //actor 0x110, trigger 0x0c4, spawn 0x0c8, entrance 0x068, container 0x0c0, item 0x014, vertex 0x004, ambient 0x0d4, variable 0x050, door 0x0c8, animation 0x04c, automap 0x034, projectile 0x01c
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	READ_LONG  0x054 aco //actor_off
	READ_LONG  0x05c tro //trigger_off
	READ_LONG  0x060 spo //spawn_off
	READ_LONG  0x068 eno //entrance_off
	READ_LONG  0x070 coo //container_off
	READ_LONG  0x078 ito //item_off
	READ_LONG  0x07c veo //vertex_off
	READ_LONG  0x084 amo //ambient_off
	READ_LONG  0x088 vao //variable_off
	READ_SHORT 0x090 ofo //object_flag_off
	READ_LONG  0x0a0 exo //explored_off
	READ_LONG  0x0a8 doo //door_off
	READ_LONG  0x0b0 ano //animation_off
	READ_LONG  0x0b8 too //tiled_off
	READ_LONG  0x0bc soo //song_off
	READ_LONG  0x0c0 reo //rest_off
	READ_LONG  0x0c4 auo //automap_off
	READ_LONG  0x0cc pro //projectile_off
	PATCH_MATCH ~%type%~ WITH
		~actor~      BEGIN SET size = num * 0x110 SET off = aco END
		~trigger~    BEGIN SET size = num * 0x0c4 SET off = tro END
		~spawn~      BEGIN SET size = num * 0x0c8 SET off = spo END
		~entrance~   BEGIN SET size = num * 0x068 SET off = eno END
		~container~  BEGIN SET size = num * 0x0c0 SET off = coo END
		~item~       BEGIN SET size = num * 0x014 SET off = ito END
		~vertex~     BEGIN SET size = num * 0x004 SET off = veo END
		~ambient~    BEGIN SET size = num * 0x0d4 SET off = amo END
		~variable~   BEGIN SET size = num * 0x050 SET off = vao END
		~door~       BEGIN SET size = num * 0x0c8 SET off = doo END
		~animation~  BEGIN SET size = num * 0x04c SET off = ano END
		~automap~    BEGIN SET size = num * 0x034 SET off = auo END
		~projectile~ BEGIN SET size = num * 0x01c SET off = pro END
		DEFAULT
			SET size = 0
			SET off = 0
	END
	PATCH_IF ( size != 0 ) AND ( off != 0 ) BEGIN
		PATCH_IF ( ~%type%~ STR_CMP ~actor~ )      AND ( aco >= off ) BEGIN WRITE_LONG  0x054 aco + size END
		PATCH_IF ( ~%type%~ STR_CMP ~trigger~ )    AND ( tro >= off ) BEGIN WRITE_LONG  0x05c tro + size END
		PATCH_IF ( ~%type%~ STR_CMP ~spawn~ )      AND ( spo >= off ) BEGIN WRITE_LONG  0x060 spo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~entrance~ )   AND ( eno >= off ) BEGIN WRITE_LONG  0x068 eno + size END
		PATCH_IF ( ~%type%~ STR_CMP ~container~ )  AND ( coo >= off ) BEGIN WRITE_LONG  0x070 coo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~item~ )       AND ( ito >= off ) BEGIN WRITE_LONG  0x078 ito + size END
		PATCH_IF ( ~%type%~ STR_CMP ~vertex~ )     AND ( veo >= off ) BEGIN WRITE_LONG  0x07c veo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~ambient~ )    AND ( amo >= off ) BEGIN WRITE_LONG  0x084 amo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~variable~ )   AND ( vao >= off ) BEGIN WRITE_LONG  0x088 vao + size END
		PATCH_IF                                       ( ofo >= off ) BEGIN WRITE_SHORT 0x090 ofo + size END
		PATCH_IF                                       ( exo >= off ) BEGIN WRITE_LONG  0x0a0 exo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~door~ )       AND ( doo >= off ) BEGIN WRITE_LONG  0x0a8 doo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~animation~ )  AND ( ano >= off ) BEGIN WRITE_LONG  0x0b0 ano + size END
		PATCH_IF                                       ( too >= off ) BEGIN WRITE_LONG  0x0b8 too + size END
		PATCH_IF                                       ( soo >= off ) BEGIN WRITE_LONG  0x0bc soo + size END
		PATCH_IF                                       ( reo >= off ) BEGIN WRITE_LONG  0x0c0 reo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~automap~ )    AND ( auo >= off ) BEGIN WRITE_LONG  0x0c4 auo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~projectile~ ) AND ( pro >= off ) BEGIN WRITE_LONG  0x0cc pro + size END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

//BLOCK FC_GET_XY_COORDINATE
DEFINE_PATCH_FUNCTION FC_GET_XY_COORDINATE
	INT_VAR num = 0
	RET     x1 y1
BEGIN
	y1 = ( num >> 16 )
	x1 = num - ( y1 << 16 )
END
//BLOCKEND

//BLOCK FC_UPDATE_VERTEX_INDEX
DEFINE_PATCH_FUNCTION FC_UPDATE_VERTEX_INDEX
	INT_VAR skip = 0 numx = 100000 adds = 100000
	STR_VAR type = trigger //trigger, container, door
BEGIN
	READ_SHORT 0x5a type_cnt
	READ_LONG  0x5c type_off
	PATCH_IF ( type_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < type_cnt ; ++i ) BEGIN
			PATCH_IF ( ~%type%~ STR_EQ ~trigger~ ) AND ( i = skip ) BEGIN END ELSE BEGIN
				READ_LONG type_off + i * 0x0c4 + 0x2c f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c4 + 0x2c f_vert + adds END
			END
		END
	END
	READ_SHORT 0x74 type_cnt
	READ_LONG  0x70 type_off
	PATCH_IF ( type_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < type_cnt ; ++i ) BEGIN
			PATCH_IF ( ~%type%~ STR_EQ ~container~ ) AND ( i = skip ) BEGIN END ELSE BEGIN
				READ_LONG type_off + i * 0x0c0 + 0x50 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c0 + 0x50 f_vert + adds END
			END
		END
	END
	READ_LONG  0xa4 type_cnt
	READ_LONG  0xa8 type_off
	PATCH_IF ( type_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < type_cnt ; ++i ) BEGIN
			PATCH_IF ( ~%type%~ STR_EQ ~door~ ) AND ( i = skip ) BEGIN END ELSE BEGIN
				READ_LONG type_off + i * 0x0c8 + 0x2c f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x2c f_vert + adds END
				READ_LONG type_off + i * 0x0c8 + 0x34 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x34 f_vert + adds END
				READ_LONG type_off + i * 0x0c8 + 0x48 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x48 f_vert + adds END
				READ_LONG type_off + i * 0x0c8 + 0x50 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x50 f_vert + adds END
			END
		END
	END
END
//BLOCKEND

//BLOCK FC_EDIT_AREA_DOOR
DEFINE_PATCH_FUNCTION FC_EDIT_AREA_DOOR
	INT_VAR
		flags           = "-1"
		hp              = "-1"
		ac              = "-1"
		cursor_idx      = "-1"
		trap_detect_dif = "-1"
		trap_remove_dif = "-1"
		is_trapped      = "-1"
		is_trap_detect  = "-1"
		launch_x        = "-1"
		launch_y        = "-1"
		detect_diff     = "-1"
		lock_diff       = "-1"
		open_loc_x      = "-1"
		open_loc_y      = "-1"
		close_loc_x     = "-1"
		close_loc_y     = "-1"
		unlock_message  = 99999999
		speaker_name    = 99999999
		//vertex_open_X
		//vertex_closed_X
		//impeded_open_X
		//impeded_closed_X
		vertex_open_0 = "-1"
		vertex_closed_0 = "-1"
		impeded_open_0 = "-1"
		impeded_closed_0 = "-1"
		// AND ( $vertex(0) >= 0 ) 
	STR_VAR
		match_name      = "same"
		match_key       = "same"
		match_script    = "same"
		name            = "same"
		doorId          = "same"
		open_sound      = "same"
		close_sound     = "same"
		key             = "same"
		script          = "same"
		travel_trigger  = "same"
		dialogue        = "same"
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	SET match = 0
	READ_LONG  0x0a4 ~d_cnt~
	READ_LONG  0x0a8 ~d_off~
	PATCH_IF ( is_trapped > 1 )     BEGIN SET is_trapped = 1     END
	PATCH_IF ( is_trap_detect > 1 ) BEGIN SET is_trap_detect = 1 END
	PATCH_IF ( d_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < d_cnt ; ++i ) BEGIN
			SET offset = d_off + i * 0xc8
			PATCH_IF ( ~%match_name%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset d_name (32) NULL
				PATCH_IF ( ~%match_name%~ STR_EQ ~%d_name%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_key%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x78 d_key (8) NULL
				PATCH_IF ( ~%match_key%~ STR_EQ ~%d_key%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_script%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x80 d_scr (8) NULL
				PATCH_IF ( ~%match_script%~ STR_EQ ~%d_scr%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF (match) BEGIN SET door_pos = i SET i = d_cnt SET patch_offset = offset END
		END
	END
	PATCH_IF (match) BEGIN
		PATCH_IF ( ~%name%~           STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset        ~%name%~           (32) END
		PATCH_IF ( ~%doorId%~         STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x20 ~%doorId%~         (8)  END
		PATCH_IF ( ~%flags%~ >= 0 )                    BEGIN WRITE_LONG   patch_offset + 0x28 ~%flags%~               END
		PATCH_IF ( ~%hp%~ >= 0 )                       BEGIN WRITE_SHORT  patch_offset + 0x54 ~%hp%~                  END
		PATCH_IF ( ~%ac%~ >= 0 )                       BEGIN WRITE_SHORT  patch_offset + 0x56 ~%ac%~                  END
		PATCH_IF ( ~%open_sound%~     STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x58 ~%open_sound%~     (8)  END
		PATCH_IF ( ~%close_sound%~    STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x60 ~%close_sound%~    (8)  END
		PATCH_IF ( ~%cursor_idx%~ >= 0 )               BEGIN WRITE_LONG   patch_offset + 0x68 ~%cursor_idx%~          END
		PATCH_IF ( ~%trap_detect_dif%~ >= 0 )          BEGIN WRITE_SHORT  patch_offset + 0x6c ~%trap_detect_dif%~     END
		PATCH_IF ( ~%trap_remove_dif%~ >= 0 )          BEGIN WRITE_SHORT  patch_offset + 0x6e ~%trap_remove_dif%~     END
		PATCH_IF ( ~%is_trapped%~ >= 0 )               BEGIN WRITE_SHORT  patch_offset + 0x70 ~%is_trapped%~          END
		PATCH_IF ( ~%is_trap_detect%~ >= 0 )           BEGIN WRITE_SHORT  patch_offset + 0x72 ~%is_trap_detect%~      END
		PATCH_IF ( ~%launch_x%~ >= 0 )                 BEGIN WRITE_SHORT  patch_offset + 0x74 ~%launch_x%~            END
		PATCH_IF ( ~%launch_y%~ >= 0 )                 BEGIN WRITE_SHORT  patch_offset + 0x76 ~%launch_y%~            END
		PATCH_IF ( ~%key%~            STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x78 ~%key%~            (8)  END
		PATCH_IF ( ~%script%~         STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x80 ~%script%~         (8)  END
		PATCH_IF ( ~%detect_diff%~ >= 0 )              BEGIN WRITE_LONG   patch_offset + 0x88 ~%detect_diff%~         END
		PATCH_IF ( ~%lock_diff%~ >= 0 )                BEGIN WRITE_LONG   patch_offset + 0x8c ~%lock_diff%~           END
		PATCH_IF ( ~%open_loc_x%~ >= 0 )               BEGIN WRITE_SHORT  patch_offset + 0x90 ~%open_loc_x%~          END
		PATCH_IF ( ~%open_loc_y%~ >= 0 )               BEGIN WRITE_SHORT  patch_offset + 0x92 ~%open_loc_y%~          END
		PATCH_IF ( ~%close_loc_x%~ >= 0 )              BEGIN WRITE_SHORT  patch_offset + 0x94 ~%close_loc_x%~         END
		PATCH_IF ( ~%close_loc_y%~ >= 0 )              BEGIN WRITE_SHORT  patch_offset + 0x96 ~%close_loc_y%~         END
		PATCH_IF ( ~%unlock_message%~ != 99999999 )    BEGIN WRITE_LONG   patch_offset + 0x98 ~%unlock_message%~      END
		PATCH_IF ( ~%travel_trigger%~ STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x9c ~%travel_trigger%~ (24) END
		PATCH_IF ( ~%speaker_name%~   != 99999999 )    BEGIN WRITE_LONG   patch_offset + 0xb4 ~%speaker_name%~        END
		PATCH_IF ( ~%dialogue%~       STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0xb8 ~%dialogue%~       (8)  END
		//vertex_open_X
		PATCH_IF ( VARIABLE_IS_SET $vertex_open(0) AND ( $vertex_open(0) >= 0 ) ) BEGIN
			READ_LONG  patch_offset + 0x2c vertex_first
			READ_SHORT patch_offset + 0x30 vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex_open(~%i%~) ) BEGIN
					SET v_num = $vertex_open(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x30 num_v
			WRITE_SHORT patch_offset + 0x38 x_bounding_left
			WRITE_SHORT patch_offset + 0x3a x_bounding_top
			WRITE_SHORT patch_offset + 0x3c x_bounding_right
			WRITE_SHORT patch_offset + 0x3e x_bounding_bottom
			READ_LONG   patch_offset + 0x34 upd_vert_1
			READ_LONG   patch_offset + 0x48 upd_vert_2
			READ_LONG   patch_offset + 0x50 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x34 upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x48 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x50 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex_open
		END
		//vertex_closed_X
		PATCH_IF ( VARIABLE_IS_SET $vertex_closed(0) AND ( $vertex_closed(0) >= 0 ) ) BEGIN
			READ_LONG  patch_offset + 0x34 vertex_first
			READ_SHORT patch_offset + 0x32 vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex_closed(~%i%~) ) BEGIN
					SET v_num = $vertex_closed(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x32 num_v
			WRITE_SHORT patch_offset + 0x40 x_bounding_left
			WRITE_SHORT patch_offset + 0x42 x_bounding_top
			WRITE_SHORT patch_offset + 0x44 x_bounding_right
			WRITE_SHORT patch_offset + 0x46 x_bounding_bottom
			READ_LONG   patch_offset + 0x2c upd_vert_1
			READ_LONG   patch_offset + 0x48 upd_vert_2
			READ_LONG   patch_offset + 0x50 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x2c upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x48 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x50 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex_closed
		END
		//impeded_open_X
		PATCH_IF ( VARIABLE_IS_SET $impeded_open(0) AND ( $impeded_open(0) >= 0 ) ) BEGIN
			READ_LONG  patch_offset + 0x48 vertex_first
			READ_SHORT patch_offset + 0x4c vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $impeded_open(~%i%~) ) BEGIN
					SET v_num = $impeded_open(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x4c num_v
			READ_LONG   patch_offset + 0x2c upd_vert_1
			READ_LONG   patch_offset + 0x34 upd_vert_2
			READ_LONG   patch_offset + 0x50 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x2c upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x34 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x50 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY impeded_open
		END
		//impeded_closed_X
		PATCH_IF ( VARIABLE_IS_SET $impeded_closed(0) AND ( $impeded_closed(0) >= 0 ) ) BEGIN
			READ_LONG  patch_offset + 0x50 vertex_first
			READ_SHORT patch_offset + 0x4e vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $impeded_closed(~%i%~) ) BEGIN
					SET v_num = $impeded_closed(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x4e num_v
			READ_LONG   patch_offset + 0x2c upd_vert_1
			READ_LONG   patch_offset + 0x34 upd_vert_2
			READ_LONG   patch_offset + 0x48 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x2c upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x34 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x48 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY impeded_closed
		END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

//BLOCK FC_EDIT_AREA_REGION
DEFINE_PATCH_FUNCTION FC_EDIT_AREA_REGION
	INT_VAR
		region_type     = "-1"
		trigger_value   = "-1"
		cursor_idx      = "-1"
		flags           = "-1"
		info_text       = 99999999
		trap_detect_dif = "-1"
		trap_remove_dif = "-1"
		is_trapped      = "-1"
		is_trap_detect  = "-1"
		launch_x        = "-1"
		launch_y        = "-1"
		alt_point_x     = "-1"
		alt_point_y     = "-1"
		//vertex_X
		vertex_0        = "-1"
	STR_VAR
		match_name      = "same"
		match_key       = "same"
		match_script    = "same"
		name            = "same"
		dest_area       = "same"
		entrance        = "same"
		key             = "same"
		script          = "same"
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	SET match = 0
	READ_SHORT 0x05a ~d_cnt~
	READ_LONG  0x05c ~d_off~
	PATCH_IF ( region_type > 2 )    BEGIN SET region_type = 1    END
	PATCH_IF ( is_trapped > 1 )     BEGIN SET is_trapped = 1     END
	PATCH_IF ( is_trap_detect > 1 ) BEGIN SET is_trap_detect = 1 END
	PATCH_IF ( d_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < d_cnt ; ++i ) BEGIN
			SET offset = d_off + i * 0xc4
			PATCH_IF ( ~%match_name%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset d_name (32) NULL
				PATCH_IF ( ~%match_name%~ STR_EQ ~%d_name%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_key%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x74 d_key (8) NULL
				PATCH_IF ( ~%match_key%~ STR_EQ ~%d_key%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_script%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x7c d_scr (8) NULL
				PATCH_IF ( ~%match_script%~ STR_EQ ~%d_scr%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF (match) BEGIN SET door_pos = i SET i = d_cnt SET patch_offset = offset END
		END
	END
	PATCH_IF (match) BEGIN
		PATCH_IF ( ~%name%~      STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset        ~%name%~       (32) END
		PATCH_IF ( ~%region_type%~ >= 0 )         BEGIN WRITE_SHORT  patch_offset + 0x20 ~%region_type%~     END
		PATCH_IF ( ~%trigger_value%~ >= 0 )       BEGIN WRITE_LONG   patch_offset + 0x30 ~%trigger_value%~   END
		PATCH_IF ( ~%cursor_idx%~ >= 0 )          BEGIN WRITE_LONG   patch_offset + 0x34 ~%cursor_idx%~      END
		PATCH_IF ( ~%dest_area%~ STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x38 ~%dest_area%~  (8)  END
		PATCH_IF ( ~%entrance%~  STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x40 ~%entrance%~   (32) END
		PATCH_IF ( ~%flags%~ >= 0 )               BEGIN WRITE_LONG   patch_offset + 0x60 ~%flags%~           END
		PATCH_IF ( ~%info_text%~ != 99999999 )    BEGIN WRITE_LONG   patch_offset + 0x64 ~%info_text%~       END
		PATCH_IF ( ~%trap_detect_dif%~ >= 0 )     BEGIN WRITE_SHORT  patch_offset + 0x68 ~%trap_detect_dif%~ END
		PATCH_IF ( ~%trap_remove_dif%~ >= 0 )     BEGIN WRITE_SHORT  patch_offset + 0x6a ~%trap_remove_dif%~ END
		PATCH_IF ( ~%is_trapped%~ >= 0 )          BEGIN WRITE_SHORT  patch_offset + 0x6c ~%is_trapped%~      END
		PATCH_IF ( ~%is_trap_detect%~ >= 0 )      BEGIN WRITE_SHORT  patch_offset + 0x6e ~%is_trap_detect%~  END
		PATCH_IF ( ~%launch_x%~ >= 0 )            BEGIN WRITE_SHORT  patch_offset + 0x70 ~%launch_x%~        END
		PATCH_IF ( ~%launch_y%~ >= 0 )            BEGIN WRITE_SHORT  patch_offset + 0x72 ~%launch_y%~        END
		PATCH_IF ( ~%key%~       STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x74 ~%key%~        (8)  END
		PATCH_IF ( ~%script%~    STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x7c ~%script%~     (8)  END
		PATCH_IF ( ~%alt_point_x%~ >= 0 )         BEGIN WRITE_SHORT  patch_offset + 0x84 ~%alt_point_x%~     END
		PATCH_IF ( ~%alt_point_y%~ >= 0 )         BEGIN WRITE_SHORT  patch_offset + 0x86 ~%alt_point_y%~     END
		PATCH_IF ( VARIABLE_IS_SET $vertex(0) AND ( $vertex(0) >= 0 ) ) BEGIN
			READ_SHORT patch_offset + 0x2a vertex_cnt
			READ_LONG  patch_offset + 0x2c vertex_first
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex(~%i%~) ) BEGIN
					SET v_num = $vertex(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x2a num_v
			WRITE_SHORT patch_offset + 0x22 x_bounding_left
			WRITE_SHORT patch_offset + 0x24 x_bounding_top
			WRITE_SHORT patch_offset + 0x26 x_bounding_right
			WRITE_SHORT patch_offset + 0x28 x_bounding_bottom
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = trigger
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex
		END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

//BLOCK FC_EDIT_AREA_CONTAINER
DEFINE_PATCH_FUNCTION FC_EDIT_AREA_CONTAINER
	INT_VAR
		loc_x           = "-1"
		loc_y           = "-1"
		type            = "-1"
		lock_diff       = "-1"
		flags           = "-1"
		trap_detect_dif = "-1"
		trap_remove_dif = "-1"
		is_trapped      = "-1"
		is_trap_detect  = "-1"
		launch_x        = "-1"
		launch_y        = "-1"
		active_range    = "-1"
		break_diff      = "-1"
		lpick_text      = 99999999
		//vertex_X
		vertex_0        = "-1"
	STR_VAR
		match_name      = "same"
		match_key       = "same"
		match_script    = "same"
		match_owner     = "same"
		name            = "same"
		script          = "same"
		owner           = "same"
		key             = "same"
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	SET match = 0
	READ_SHORT 0x074 ~d_cnt~
	READ_LONG  0x070 ~d_off~
	PATCH_IF ( type > 12 )          BEGIN SET type           = 4 END
	PATCH_IF ( is_trapped > 1 )     BEGIN SET is_trapped     = 1 END
	PATCH_IF ( is_trap_detect > 1 ) BEGIN SET is_trap_detect = 1 END /* */
	PATCH_IF ( d_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < d_cnt ; ++i ) BEGIN
			SET offset = d_off + i * 0xc0
			PATCH_IF ( ~%match_name%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset d_name (32) NULL
				PATCH_IF ( ~%match_name%~ STR_EQ ~%d_name%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_key%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x78 d_key (8) NULL
				PATCH_IF ( ~%match_key%~ STR_EQ ~%d_key%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_script%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x48 d_scr (8) NULL
				PATCH_IF ( ~%match_script%~ STR_EQ ~%d_scr%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_owner%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x58 d_owner (32) NULL
				PATCH_IF ( ~%match_owner%~ STR_EQ ~%d_owner%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF (match) BEGIN SET door_pos = i SET i = d_cnt SET patch_offset = offset END
		END
	END
	PATCH_IF (match) BEGIN
		PATCH_IF ( ~%name%~      STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset        ~%name%~       (32) END
		PATCH_IF ( ~%loc_x%~ >= 0               ) BEGIN WRITE_SHORT  patch_offset + 0x20 ~%loc_x%~           END
		PATCH_IF ( ~%loc_y%~ >= 0               ) BEGIN WRITE_SHORT  patch_offset + 0x22 ~%loc_y%~           END
		PATCH_IF ( ~%type%~  >= 1               ) BEGIN WRITE_SHORT  patch_offset + 0x24 ~%type%~            END
		PATCH_IF ( ~%lock_diff%~ >= 0           ) BEGIN WRITE_SHORT  patch_offset + 0x26 ~%lock_diff%~       END
		PATCH_IF ( ~%flags%~ >= 0               ) BEGIN WRITE_LONG   patch_offset + 0x28 ~%flags%~           END
		PATCH_IF ( ~%trap_detect_dif%~ >= 0     ) BEGIN WRITE_SHORT  patch_offset + 0x2c ~%trap_detect_dif%~ END
		PATCH_IF ( ~%trap_remove_dif%~ >= 0     ) BEGIN WRITE_SHORT  patch_offset + 0x2e ~%trap_remove_dif%~ END
		PATCH_IF ( ~%is_trapped%~ >= 0          ) BEGIN WRITE_SHORT  patch_offset + 0x30 ~%is_trapped%~      END
		PATCH_IF ( ~%is_trap_detect%~ >= 0      ) BEGIN WRITE_SHORT  patch_offset + 0x32 ~%is_trap_detect%~  END
		PATCH_IF ( ~%launch_x%~ >= 0            ) BEGIN WRITE_SHORT  patch_offset + 0x34 ~%launch_x%~        END
		PATCH_IF ( ~%launch_y%~ >= 0            ) BEGIN WRITE_SHORT  patch_offset + 0x36 ~%launch_y%~        END
		PATCH_IF ( ~%script%~    STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x48 ~%script%~      (8) END
		PATCH_IF ( ~%active_range%~ >= 0        ) BEGIN WRITE_SHORT  patch_offset + 0x56 ~%active_range%~    END
		PATCH_IF ( ~%owner%~     STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x58 ~%owner%~      (32) END
		PATCH_IF ( ~%key%~       STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x78 ~%key%~         (8) END
		PATCH_IF ( ~%break_diff%~ >= 0          ) BEGIN WRITE_LONG   patch_offset + 0x80 ~%break_diff%~      END
		PATCH_IF ( ~%lpick_text%~ !=   99999999 ) BEGIN WRITE_LONG   patch_offset + 0x84 ~%lpick_text%~      END
		PATCH_IF ( VARIABLE_IS_SET $vertex(0) AND ( $vertex(0) >= 0 ) ) BEGIN
			READ_SHORT patch_offset + 0x54 vertex_cnt
			READ_LONG  patch_offset + 0x50 vertex_first
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex(~%i%~) ) BEGIN
					SET v_num = $vertex(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x54 num_v
			WRITE_SHORT patch_offset + 0x38 x_bounding_left
			WRITE_SHORT patch_offset + 0x3a x_bounding_top
			WRITE_SHORT patch_offset + 0x3c x_bounding_right
			WRITE_SHORT patch_offset + 0x3e x_bounding_bottom
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = container
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex
		END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

/* CONVERT_SPL_TO_INNATE */
DEFINE_PATCH_MACRO CONVERT_SPL_TO_INNATE BEGIN
  WRITE_SHORT 0x1c 4
  WRITE_LONG  0x1e 0
  WRITE_LONG  0x34 1
  READ_LONG   0x64 abil_off
  READ_SHORT  0x68 abil_num
  PATCH_IF ( abil_num > 0 ) BEGIN //0x28
    FOR ( i = 0 ; i < abil_num ; ++i ) BEGIN
      WRITE_SHORT abil_off + i * 0x28 + 0x2 4
    END
  END
END

/* APPEND_STATDESC_ENTRY */
DEFINE_ACTION_FUNCTION APPEND_STATDESC_ENTRY
INT_VAR
  strref   = "-1"
STR_VAR
  bam_file = "****"
RET
  index
BEGIN
  OUTER_SET index = "-1"
  OUTER_SET minus = "-1"  
  ACTION_IF ( strref >= 0 ) OR !( bam_file STRING_EQUAL ~****~ ) BEGIN
    ACTION_IF ( bam_file STRING_EQUAL ~~ ) BEGIN
      OUTER_TEXT_SPRINT bam_file ~****~
    END    
    ACTION_IF (FILE_EXISTS_IN_GAME ~statdesc.2da~) BEGIN
      COPY_EXISTING ~statdesc.2da~ ~override~
        COUNT_2DA_ROWS 3 table
        FOR ( idx = 0 ; idx < table ; ++idx ) BEGIN
          READ_2DA_ENTRY idx 0 3 number
          READ_2DA_ENTRY idx 1 3 curStrref
          READ_2DA_ENTRY idx 2 3 curBam
          PATCH_IF ( idx < number ) BEGIN
            TEXT_SPRINT line ~%idx%         %strref%         %bam_file%~
            INSERT_2DA_ROW idx 3 ~%line%~
            SET index = idx
            SET idx = table + 1
          END
          PATCH_IF ( ~%curStrref%~ = ~%minus%~ ) AND ( ~%curBam%~ STRING_EQUAL ~****~ ) AND ( index < 0 ) BEGIN
            SET_2DA_ENTRY idx 1 3 ~%strref%~
            SET_2DA_ENTRY idx 2 3 ~%bam_file%~
            SET index = number
            SET idx = table + 1
          END
        END        
        PATCH_IF ( index < 0 ) BEGIN
          TEXT_SPRINT line ~%table%         %strref%         %bam_file%~
          INSERT_2DA_ROW table 3 ~%line%~
          SET index = table
        END        
        PRETTY_PRINT_2DA
      BUT_ONLY
    END
  END
END


/** COPY_SPL_ABILITY
  ability 0x28
  effect  0x30
*/
DEFINE_PATCH_FUNCTION COPY_SPL_ABILITY
INT_VAR
  inc_timing       = 1
  timing_increment = 6
  num_copies       = 1
  inc_lvl          = 1
  increment_lvl    = 1
STR_VAR
  
BEGIN
  PATCH_IF ( num_copies < 1)       BEGIN SET num_copies = 1       END
  PATCH_IF ( timing_increment < 1) BEGIN SET timing_increment = 6 END
  PATCH_IF ( increment_lvl < 1)    BEGIN SET increment_lvl = 1    END
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_cnt
  READ_LONG  0x6a seff_off
  READ_SHORT 0x70 seff_cnt
  SET eff_off = seff_off + seff_cnt * 0x30
  PATCH_IF ( abil_cnt = 1 ) BEGIN
    READ_SHORT abil_off + 0x1e eff_cnt
    READ_SHORT abil_off + 0x20 eff_first
    READ_SHORT abil_off + 0x10 level
    //COPY EFFECTS
    SET len = eff_cnt * 0x30
    READ_ASCII eff_off data (%len%)
    FOR ( i = 0 ; i < num_copies ; ++i ) BEGIN
      SET eff_off = eff_off + len
      INSERT_BYTES eff_off len
      WRITE_EVALUATED_ASCII  eff_off ~%data%~ (%len%)
    END
    //COPY ABILITY
    SET len = 0x28
    READ_ASCII abil_off data (%len%)
    FOR ( i = 0 ; i < num_copies ; ++i ) BEGIN
      SET abil_off = abil_off + len
      INSERT_BYTES abil_off len
      WRITE_EVALUATED_ASCII  abil_off ~%data%~ (%len%)
      PATCH_IF ( inc_lvl = 1 ) BEGIN
        SET level = level + increment_lvl
        WRITE_SHORT abil_off + 0x10 level
      END
      SET abil_cnt = abil_cnt + 1
      SET eff_first = eff_first + eff_cnt
      WRITE_SHORT abil_off + 0x20 eff_first
      SET seff_off = seff_off + len
    END
    WRITE_SHORT 0x68 abil_cnt
    WRITE_LONG  0x6a seff_off
    //INCREMENT TIMING
    PATCH_IF ( inc_timing = 1 ) BEGIN
      READ_LONG  0x64 abil_off
      READ_SHORT 0x68 abil_cnt
      FOR ( i = 0 ; i < abil_cnt ; ++i ) BEGIN
        PATCH_IF ( i > 0 ) BEGIN
          SET offset = abil_off + 0x28 * i
          READ_SHORT offset + 0x1e eff_cnt
          READ_SHORT offset + 0x20 first
          FOR ( j = 0 ; j < eff_cnt ; ++j ) BEGIN
            SET eoffset = seff_off + first * 0x30 + j * 0x30
            READ_BYTE  eoffset + 0x0c time
            PATCH_IF ( time != 1 ) AND ( time != 9 ) BEGIN
              READ_LONG  eoffset + 0x0e duration
              PATCH_IF ( duration >= 6 ) BEGIN
                SET duration = duration + timing_increment * i
                WRITE_LONG  eoffset + 0x0e duration
              END
            END
          END
        END
      END
    END
  END
END


/* ADD_SAVE_GAME */
DEFINE_ACTION_FUNCTION ADD_SAVE_GAME
	INT_VAR
		strref    = "-1"
		num_saves = 1
		start     = "-1"
	STR_VAR
		
	RET
		index
BEGIN
	OUTER_SET index = "-1"
	COPY_EXISTING ~savename.2da~ ~override~
		PATCH_IF ( num_saves < 0 ) BEGIN SET num_saves = 1 END
		COUNT_2DA_ROWS 4 num_rows
		FOR ( i = 0 ; i < num_rows ; ++i ) BEGIN
			READ_2DA_ENTRY i 0 4 val
			PATCH_IF (!VARIABLE_IS_SET $values(~%val%~)) BEGIN
				DEFINE_ASSOCIATIVE_ARRAY values BEGIN ~%val%~ => ~~ END
			END
		END //65535
		FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
			PATCH_IF (!VARIABLE_IS_SET $values(~%i%~)) BEGIN
				PATCH_IF ( start < 0 ) BEGIN SET start = i END
				INSERT_2DA_ROW i 4 ~%i%  %strref%  %start%  %num_saves%~
				SET index = i
				SET i = 65535 + 1
			END
		END
		PRETTY_PRINT_2DA
END

//BLOCK REPLACE_MULTILINE
//Patch function that replaces set or all occurrences of the given regexp pattern in the file with the given string.
//Use EVAL to perform variable substitution on the string and/or the regexp pattern.
//Unlike REPLACE_TEXTUALLY the pattern can be multi-line text, even without using regexp.
//Just like REPLACE_BCS_BLOCK the function ignores pattern whitespace.
//The function can be also used as a COUNT_REGEXP_INSTANCES alternative with the above mentioned features.
//Optional PATCH_WARN message is printed if the task could not be performed (pattern not found or different amount of pattern matches than expected).

DEFINE_PATCH_FUNCTION REPLACE_MULTILINE
	INT_VAR
		num = "-1"     //amount of times the pattern should be replaced with string (-1 by default which is at least 1 but without max limit)
		strict = 0     //set to 1 to enable strict checking (auto escapes $^.*+?[]\ special characters)
		verbose = 1    //set to 0 to skip printing patching message
		warn = 1       //set to 0 to skip printing warning message if the function can't do what you ask it to do
		only_count = 0 //set to to 1 to skip pattern replacing and just return num_matches (COUNT_REGEXP_INSTANCES alternative)
	STR_VAR
		pattern = ""   //pattern that you want to replace
		string = ""    //string that the pattern will be replaced with
	RET
		num_matches    //amount of times the pattern has been found
	BEGIN
	TEXT_SPRINT percent ~%~
	INNER_PATCH_SAVE textToReplace ~%pattern%~ BEGIN
		PATCH_IF strict = 1 BEGIN
			REPLACE_TEXTUALLY ~\\~ ~\\\\~
			REPLACE_TEXTUALLY ~\[~ ~\[~
			REPLACE_TEXTUALLY ~\]~ ~\]~
			REPLACE_EVALUATE ~\([\$\^\.\*\+\?]\)~ BEGIN END ~\%MATCH1%~
		END
		REPLACE_TEXTUALLY ~[%WNL%%LNL%%MNL%%TAB% ]+~ ~[%WNL%%LNL%%MNL%%TAB% ]+~
	END
	SET num_matches = 0
	PATCH_IF only_count = 0 BEGIN
		REPLACE_EVALUATE CASE_INSENSITIVE ~%textToReplace%~ BEGIN
			SET num_matches = num_matches + 1
			INNER_PATCH_SAVE string ~%string%~ BEGIN
				REPLACE_TEXTUALLY ~%percent%MATCH\([0-9]+\)%percent%~ ~%MATCH\1%~
			END
		END ~%string%~
		SET warned = 0
		PATCH_IF num_matches != num BEGIN
			PATCH_IF num_matches = 0 BEGIN
				PATCH_IF warn = 1 BEGIN
					PATCH_WARN ~WARNING %SOURCE_FILESPEC% - pattern not found:%LNL%%pattern%~
				END
				SET warned = 1
			END ELSE PATCH_IF num >= 0 AND (num_matches > num OR num_matches < num) BEGIN
				PATCH_IF warn = 1 BEGIN
					PATCH_WARN ~WARNING %SOURCE_FILESPEC% - pattern replaced %num_matches% time(s) instead of %num%:%LNL%%pattern%~
				END
				SET warned = 1
			END
		END
		PATCH_IF verbose = 1 AND warned = 0 BEGIN
			PATCH_PRINT ~Patching %SOURCE_FILESPEC% - pattern replaced %num_matches% time(s):%LNL%%pattern% => %string%~
		END
	END ELSE BEGIN
		COUNT_REGEXP_INSTANCES ~%textToReplace%~ num_matches
	END
END
//BLOCKEND

//BLOCK DLG_FUNCTIONS
// :
//OUTER_SPRINT ~ssstr~ ~  ~ // @XXX,         
//LAF FC_APPEND_TO_DLGS
//	INT_VAR
//		state_to_patch = 26 // State     
//	STR_VAR
//		dlg = "EDWIN" //  dlg 
//		str = EVAL ~%ssstr%~ //   (   ) *
//END
DEFINE_ACTION_FUNCTION FC_COMPILE_EXTERNAL_DLG
	INT_VAR
		lbl  = "-1"
		nlbl = "-1"
	STR_VAR
		dlg_patch = ""
		dlg_orig  = ""
		string    = ""
BEGIN
<<<<<<<< inl_dlg.d
ALTER_TRANS %dlg_patch% BEGIN %nlbl% END BEGIN 0 END BEGIN "EPILOGUE" ~EXTERN %dlg_orig% XXX1~ END

CHAIN
IF ~~ THEN %dlg_orig% XXX1
  ~%string%~
END %dlg_orig% %lbl%
>>>>>>>>
	COMPILE ~inl_dlg.d~ EVALUATE_BUFFER
END

DEFINE_ACTION_FUNCTION FC_APPEND_TO_DLGS
	INT_VAR
		state_to_patch = "-1"
	STR_VAR
		dlg = ""
		str = ""
BEGIN
	ACTION_CLEAR_ARRAY STATE_LABEL_ARRAY
	ACTION_IF FILE_EXISTS_IN_GAME ~%dlg%.dlg~ BEGIN
		COPY_EXISTING ~%dlg%.dlg~ ~override~
			READ_LONG 0x08      state_num
			READ_LONG 0x0c      state_off
			SET       n_state = "-1"
			PATCH_IF ( state_num > %state_to_patch% ) BEGIN
				SET       offset =     state_off + ~%state_to_patch%~ * 0x10
				READ_LONG offset   + 0x4 resp_fst
				READ_LONG offset   + 0x8 resp_cnt
				READ_LONG 0x10           resp_num
				READ_LONG 0x14           resp_off
				SET       resp_all =     resp_fst + resp_cnt
				PATCH_IF  ( resp_num >= resp_all ) BEGIN
					FOR ( i = resp_fst ; i < resp_all ; ++i ) BEGIN
						SET        off2 = resp_off + i * 0x20
						READ_ASCII off2 + 0x14       d_name (8) NULL
						READ_LONG  off2 + 0x1c       idx
						PATCH_IF ( n_state < 0 ) BEGIN
							SET n_state = idx
							SET idx     = state_to_patch
						END
						DEFINE_ASSOCIATIVE_ARRAY STATE_LABEL_ARRAY BEGIN
							~%dlg%~, ~%d_name%~, ~%str%~, ~%n_state%~, ~%idx%~ => ~~
						END
					END
				END
			END
			BUT_ONLY_IF_IT_CHANGES
		ACTION_PHP_EACH STATE_LABEL_ARRAY AS slb => _ BEGIN
			LAF FC_COMPILE_EXTERNAL_DLG
				INT_VAR
					lbl       =      "%slb_3%"
					nlbl      =      "%slb_4%"
				STR_VAR
					dlg_patch = EVAL "%slb_1%"
					dlg_orig  = EVAL "%slb%"
					string    = EVAL "%slb_2%"
			END
		END
	END
END
//BLOCKEND

/* GET_BIT */
DEFINE_PATCH_FUNCTION GET_BIT
INT_VAR
	number = 0
	nth_bit = 0 //  0
RET
	bit_value
BEGIN
	SET bit_value = (number >> nth_bit) & 1
END

/* GET_SCRIPT_BLOCK

 * Returns the first available script block containing the specified search string (as regular expression).
 * INT_VAR start_offset   Optional offset where to start searching. (Default: 0)
 * INT_VAR reverse        Specify zero to apply a forward search, or non-zero to apply a backwards seearch from "start_offset". (Default: 0)
 * STR_VAR search_regexp  The search string as regular expression. Must be non-empty.
 * RET script_block       The full script block as string when found, empty string otherwise.
 * RET start_offset       Start offset of the script block when found, -1 otherwise.
 * RET end_offset         End offset (directly behind closing "END") of the script block when found, -1 otherwise.
  */
DEFINE_PATCH_FUNCTION GET_SCRIPT_BLOCK
INT_VAR
  start_offset  = 0
  reverse       = 0
STR_VAR
  search_regexp = ~~
RET
  script_block
  start_offset
  end_offset
BEGIN
  SET offset = start_offset
  PATCH_IF (offset < 0) BEGIN SET offset = 0 END
  PATCH_IF (offset > BUFFER_LENGTH) BEGIN SET offset = BUFFER_LENGTH END

  TEXT_SPRINT script_block ~~
  SET start_offset = "-1"
  SET end_offset = "-1"

  PATCH_IF (NOT ~%search_regexp%~ STR_EQ ~~) BEGIN
    PATCH_IF (reverse) BEGIN
      SET offset = RINDEX_BUFFER(~%search_regexp%~ offset)
    END ELSE BEGIN
      SET offset = INDEX_BUFFER(~%search_regexp%~ offset)
    END

    PATCH_IF (offset >= 0) BEGIN
      SET ofsStart = RINDEX_BUFFER(~^IF$~ offset)
      PATCH_IF (ofsStart >= 0) BEGIN
        SET ofsEnd = INDEX_BUFFER(~^END$~ offset)
        PATCH_IF (ofsEnd >= 0) BEGIN
          SET ofsEnd += 3
          READ_ASCII ofsStart script_block (ofsEnd - ofsStart)
          SET start_offset = ofsStart
          SET end_offset = ofsEnd
        END
      END
    END
  END
END

//BLOCK  ATTACK_PER_ROUND
DEFINE_PATCH_FUNCTION ADD_ATTACK_PER_ROUND
	INT_VAR
		mode     = 1 //!0 - plus, 0 - minus
		attacks  = "-1" // <0 - automate read
		not_zero = 1 //!0 - not APR=0, 0 - allow APR=0
		write    = 1 // 0 - only return RES, !0 - return RES and write APR
	STR_VAR
		adds     = "1.0" //0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0
	RET
		attacks
BEGIN
	PATCH_IF ( attacks < 0 ) BEGIN SET attacks = ( BYTE_AT 0x53 ) END
	INNER_PATCH_SAVE ~adds~ ~%adds%~ BEGIN
		REPLACE_TEXTUALLY ~,~ ~.~
	END
	SET att  = attacks
	SET atts = 0
	SET no_patch = 0
	PATCH_IF ( mode     != 0 ) BEGIN SET mode     = 1 END
	PATCH_IF ( not_zero != 0 ) BEGIN SET not_zero = 1 END
	PATCH_IF ( write    != 0 ) BEGIN SET write    = 1 END
	PATCH_IF ( att > 10 ) OR  ( att < 0 )  BEGIN SET no_patch = 1 END
	PATCH_IF ( NOT no_patch ) BEGIN
		PATCH_MATCH att WITH
			0  BEGIN SET atts = 0  END
			1  BEGIN SET atts = 10 END
			2  BEGIN SET atts = 20 END
			3  BEGIN SET atts = 30 END
			4  BEGIN SET atts = 40 END
			5  BEGIN SET atts = 50 END
			6  BEGIN SET atts = 5  END
			7  BEGIN SET atts = 15 END
			8  BEGIN SET atts = 25 END
			9  BEGIN SET atts = 35 END
			10 BEGIN SET atts = 45 END
		DEFAULT
		END
		PATCH_IF ( mode ) BEGIN SET zxxx = 1 END ELSE BEGIN SET zxxx = ( 0 - 1 ) END
		PATCH_MATCH ~%adds%~ WITH
			"0.0" BEGIN SET atts = atts +  0        END
			"0.5" BEGIN SET atts = atts +  5 * zxxx END
			"1.0" BEGIN SET atts = atts + 10 * zxxx END
			"1.5" BEGIN SET atts = atts + 15 * zxxx END
			"2.0" BEGIN SET atts = atts + 20 * zxxx END
			"2.5" BEGIN SET atts = atts + 25 * zxxx END
			"3.0" BEGIN SET atts = atts + 30 * zxxx END
			"3.5" BEGIN SET atts = atts + 35 * zxxx END
			"4.0" BEGIN SET atts = atts + 40 * zxxx END
			"4.5" BEGIN SET atts = atts + 45 * zxxx END
			"5.0" BEGIN SET atts = atts + 50 * zxxx END
		DEFAULT
		END
		PATCH_IF ( atts > 50 )                 BEGIN SET atts = 50 END
		PATCH_IF ( atts <  0 )                 BEGIN SET atts =  0 END
		PATCH_IF ( not_zero ) AND ( atts = 0 ) BEGIN SET atts =  5 END
		PATCH_MATCH atts WITH
			0  BEGIN SET att =  0 END
			5  BEGIN SET att =  6 END
			10 BEGIN SET att =  1 END
			15 BEGIN SET att =  7 END
			20 BEGIN SET att =  2 END
			25 BEGIN SET att =  8 END
			30 BEGIN SET att =  3 END
			35 BEGIN SET att =  9 END
			40 BEGIN SET att =  4 END
			45 BEGIN SET att = 10 END
			50 BEGIN SET att =  5 END
		DEFAULT
		END
	END
	SET attacks = att
	PATCH_IF ( write ) BEGIN
		WRITE_BYTE 0x53 attacks
	END
END
//BLOCKEND

//BLOCK FC_EDIT_SAVING_THROW
DEFINE_PATCH_FUNCTION FC_EDIT_SAVING_THROW
	INT_VAR
		mode   = 1 //1 - better, 0 - worse
		all    = 0 //all saves
		death  = 0
		wand   = 0
		poly   = 0
		breath = 0
		spell  = 0
BEGIN
	PATCH_IF ( mode != 0 ) BEGIN SET mode = 1 END ELSE BEGIN SET mode = ( 0 - 1 ) END
	PATCH_IF ( all != 0 ) BEGIN
		SET death  = all
		SET wand   = all
		SET poly   = all
		SET breath = all
		SET spell  = all
	END
	PATCH_IF ( death  > 0 ) BEGIN WRITE_BYTE 0x54 ( THIS - ( death  * mode ) ) END
	PATCH_IF ( wand   > 0 ) BEGIN WRITE_BYTE 0x55 ( THIS - ( wand   * mode ) ) END
	PATCH_IF ( poly   > 0 ) BEGIN WRITE_BYTE 0x56 ( THIS - ( poly   * mode ) ) END
	PATCH_IF ( breath > 0 ) BEGIN WRITE_BYTE 0x57 ( THIS - ( breath * mode ) ) END
	PATCH_IF ( spell  > 0 ) BEGIN WRITE_BYTE 0x58 ( THIS - ( spell  * mode ) ) END
END
//BLOCKEND

//BLOCK EDIT_STORE_PURCHASE
DEFINE_PATCH_FUNCTION EDIT_STORE_PURCHASE
	INT_VAR
		type   = "-1"
		delete =   0
BEGIN
	SET add =   0
	SET ix  = "-1"
	SET off =   0
	PATCH_IF ( delete != 0 ) BEGIN SET delete = 1 SET ix = 1 END
	PATCH_IF ( type   >= 0 ) BEGIN
		READ_LONG 0x2c purch_off
		READ_LONG 0x30 purch_num
		SET add = 1
		PATCH_IF ( purch_num > 0 ) BEGIN
			FOR ( i = 0 ; i < purch_num ; ++i ) BEGIN
				READ_LONG purch_off + i * 4 tp
				PATCH_IF ( tp = type ) BEGIN
					SET i = purch_num
					PATCH_IF ( delete ) BEGIN
						SET off = i * 4
					END ELSE BEGIN
						SET add = 0
					END
				END
			END
		END
	END
	PATCH_IF ( add ) BEGIN
		READ_LONG    0x34 items_off
		READ_LONG    0x4c drink_off
		READ_LONG    0x70 cures_off
		PATCH_IF ( delete ) BEGIN
			DELETE_BYTES purch_off + off           4
			PATCH_IF ( items_off >  purch_off ) BEGIN WRITE_LONG 0x34 ( items_off - 4 ) END
			PATCH_IF ( drink_off >  purch_off ) BEGIN WRITE_LONG 0x34 ( drink_off - 4 ) END
			PATCH_IF ( cures_off >  purch_off ) BEGIN WRITE_LONG 0x34 ( cures_off - 4 ) END
		END ELSE BEGIN
			INSERT_BYTES purch_off + purch_num * 4 4
			WRITE_LONG   purch_off + purch_num * 4 type
			PATCH_IF ( items_off >= purch_off ) BEGIN WRITE_LONG 0x34 ( items_off + 4 ) END
			PATCH_IF ( drink_off >= purch_off ) BEGIN WRITE_LONG 0x34 ( drink_off + 4 ) END
			PATCH_IF ( cures_off >= purch_off ) BEGIN WRITE_LONG 0x34 ( cures_off + 4 ) END
		END
		WRITE_LONG   0x30 ( purch_num + ( 1 * ix ) )
	END
END
//BLOCKEND

//BLOCK ADD_ITEM_DIALOG
// Adds a new entry for a conversable item
DEFINE_PATCH_FUNCTION ADD_ITEM_DIALOG
	INT_VAR
		button_strref = 5689  // Default: "Converse"
		name_strref   = "-1"  // not used outside of PSTEE
	STR_VAR
		itm_resref    = ~~
		dlg_resref    = ~~
BEGIN
	PATCH_IF (NOT ~%itm_resref%~ STR_EQ ~~) BEGIN
		PATCH_IF (~%dlg_resref%~ STR_EQ ~~) BEGIN TEXT_SPRINT dlg_resref ~%itm_resref%~ END
		COUNT_2DA_COLS numCols
		COUNT_2DA_ROWS numCols numRows
		TEXT_SPRINT entry ~%itm_resref%      %button_strref%  %dlg_resref%~
		PATCH_IF (numCols > 3) BEGIN
			TEXT_SPRINT entry ~%entry% %name_strref%~
			FOR (idx = 4; idx < numCols; ++idx) BEGIN TEXT_SPRINT entry ~%entry% *~ END
		END
		INSERT_2DA_ROW numRows numCols ~%entry%~
	END
END
//BLOCKEND

//BLOCK CREATE_B_BCS_NAME
DEFINE_ACTION_FUNCTION CREATE_B_BCS_NAME
	INT_VAR
		mx_lng = 8
	STR_VAR
		namez  = ""
		prefix = ""
		suffix = ""
	RET
		result
BEGIN
	OUTER_SPRINT ~result~ ~%prefix%%namez%~
	OUTER_SET lng  = STRING_LENGTH ~%result%~
	OUTER_SET lngs = STRING_LENGTH ~%suffix%~
	ACTION_IF ( lng > mx_lng ) BEGIN OUTER_SNPRINT mx_lng ~result~ ~%result%~ END
	ACTION_IF ( lngs > 0 ) BEGIN
		OUTER_SET zzz = mx_lng - lngs
		OUTER_SNPRINT zzz ~result~ ~%result%~
		OUTER_SPRINT ~result~ ~%result%%suffix%~
	END
END
//BLOCKEND

<<<<<<<<xxx.xxx
>>>>>>>>

//BLOCK COPY_TIS_PVRZ
DEFINE_ACTION_FUNCTION FC_COPY_TIS_PVRZ
	INT_VAR
		delete_original=0 // 1 - delete original pvrz
	STR_VAR
		tis_pvrz_path = ""
		path_to_vanilla_tis = "" // using if Not find free pvrz index
		tis_name = "" // original tis-name
		tis_name_target = "" // target tis-name. if tis_name_target = "" => tis_name_target = tis_name
		target_path = "override"
BEGIN
	ACTION_IF ( ~%tis_name_target%~ STR_EQ ~~ ) BEGIN OUTER_SPRINT tis_name_target ~%tis_name%~ END
	
	MKDIR ~%MOD_FOLDER%/zzXXXzz~
	OUTER_SPRINT ~bckp~ ~%MOD_FOLDER%/zzXXXzz~
	
	ACTION_CLEAR_ARRAY FC_PVRZ_PAGE_ARRAY
	ACTION_CLEAR_ARRAY FC_OFFSET_ARRAY
	
	OUTER_PATCH_SAVE pvr_name_old ~%tis_name%~ BEGIN
		DELETE_BYTES 1 1
	END
	OUTER_PATCH_SAVE pvr_name ~%tis_name_target%~ BEGIN
		DELETE_BYTES 1 1
	END
	
	OUTER_SET original = 0
	
	ACTION_IF ( FILE_EXISTS ~%tis_pvrz_path%/%tis_name%.tis~ ) BEGIN
		COPY ~%tis_pvrz_path%/%tis_name%.tis~ ~%target_path%/%tis_name_target%.tis~
			READ_LONG 0x8  "tiles_cnt"
			READ_LONG 0x10 "tiles_off"
			READ_LONG 0xc  "tiles_length"
			SET x = 0
			SET z = 0
			FOR ( i = 0 ; i < tiles_cnt ; ++i ) BEGIN
				SET offset = tiles_off + tiles_length * i
				READ_LONG offset pvr_pg
				DEFINE_ASSOCIATIVE_ARRAY FC_OFFSET_ARRAY BEGIN ~%offset%~ => ~%pvr_pg%~ END
				PATCH_IF !( VARIABLE_IS_SET $FC_PVRZ_PAGE_ARRAY( ~%pvr_pg%~ ) ) BEGIN
					PATCH_IF ( pvr_pg < 10 ) BEGIN SPRINT pgi ~0%pvr_pg%~ END ELSE BEGIN SPRINT pgi ~%pvr_pg%~ END
					PATCH_IF ( NOT FILE_EXISTS_IN_GAME ~%pvr_name%%pgi%.PVRZ~ ) AND
					         ( NOT FILE_EXISTS ~%bckp%/%pvr_name%%pgi%.PVRZ~ ) BEGIN
						SET z = pvr_pg
						DEFINE_ASSOCIATIVE_ARRAY FC_PVRZ_PAGE_ARRAY BEGIN ~%pvr_pg%~ => ~%z%~ END
						INNER_ACTION BEGIN
							SILENT
								COPY ~xxx.xxx~ ~%bckp%/%pvr_name%%pgi%.PVRZ~
							VERBOSE
						END
					END ELSE BEGIN
						SET z = z + 1
						FOR ( j = z ; j < 100 ; ++j ) BEGIN
							PATCH_IF ( z < 10 ) BEGIN SPRINT pgi ~0%z%~ END ELSE BEGIN SPRINT pgi ~%z%~ END
							PATCH_IF ( NOT FILE_EXISTS_IN_GAME ~%pvr_name%%pgi%.PVRZ~ ) AND
					                 ( NOT FILE_EXISTS ~%bckp%/%pvr_name%%pgi%.PVRZ~ ) BEGIN
								DEFINE_ASSOCIATIVE_ARRAY FC_PVRZ_PAGE_ARRAY BEGIN ~%pvr_pg%~ => ~%j%~    END
								INNER_ACTION BEGIN
									SILENT
										COPY ~xxx.xxx~ ~%bckp%/%pvr_name%%pgi%.PVRZ~
									VERBOSE
								END
								SET j = 100
							END ELSE BEGIN
								SET z = z + 1
							END
						END
					END
				END
			END
			PATCH_IF ( z > 99 ) BEGIN SET original = 1 END
			PHP_EACH FC_OFFSET_ARRAY AS offset => value BEGIN
				SET new_value = 0
				PATCH_IF ( VARIABLE_IS_SET $FC_PVRZ_PAGE_ARRAY( ~%value%~ ) ) BEGIN
					SET new_value = $FC_PVRZ_PAGE_ARRAY( ~%value%~ )
				END
				WRITE_LONG ~%offset%~ ~%new_value%~
			END
		
		ACTION_IF ( delete_original ) BEGIN
			DELETE ~%tis_pvrz_path%/%tis_name%.tis~
		END

		ACTION_IF ( NOT original ) BEGIN
			ACTION_PHP_EACH FC_PVRZ_PAGE_ARRAY AS source => dest BEGIN
				ACTION_IF ( source < 10 ) BEGIN OUTER_SPRINT sourceX ~0%source%~ END ELSE BEGIN OUTER_SPRINT sourceX ~%source%~ END
				ACTION_IF ( dest   < 10 ) BEGIN OUTER_SPRINT destX   ~0%dest%~   END ELSE BEGIN OUTER_SPRINT destX   ~%dest%~   END
				ACTION_IF ( FILE_EXISTS ~%tis_pvrz_path%/%pvr_name_old%%sourceX%.PVRZ~ ) BEGIN
					PRINT ~%pvr_name_old%%sourceX%.PVRZ => %target_path%/%pvr_name%%destX%.PVRZ~
					SILENT
						COPY ~%tis_pvrz_path%/%pvr_name_old%%sourceX%.PVRZ~ ~%target_path%/%pvr_name%%destX%.PVRZ~
						ACTION_IF ( delete_original ) BEGIN
							DELETE ~%tis_pvrz_path%/%pvr_name_old%%sourceX%.PVRZ~
						END
					VERBOSE
				END
			END
		END ELSE BEGIN
			PRINT ~Not find free PVRZ index...~
			ACTION_IF ( ~%path_to_vanilla_tis%~ STR_CMP ~~ ) BEGIN
				ACTION_IF ( FILE_EXISTS ~%path_to_vanilla_tis%/%tis_name%.tis~ ) BEGIN
					PRINT ~Using vanilla TIS...~
					COPY ~%path_to_vanilla_tis%/%tis_name%.tis~ ~%target_path%/%tis_name_target%.tis~
				END
			END
		END
	END
END
//BLOCKEND

//BLOCK add_area_cre_acti
DEFINE_PATCH_FUNCTION ~add_area_cre_acti~
  INT_VAR
    pos_x       =   1
    pos_y       =   1
    dest_x      =   ~%pos_x%~
    dest_y      =   ~%pos_y%~
    flags       =   1
    anim        =   25602
    dir         =   0
    expiri_time = ~-1~
    wander_dist =   0
    follow_dist =   0
    present_at  =   0b11111111111111111111111111111111
    talked_to   =   0
  STR_VAR
    actor_name  = ""
    dialogue    = ""
    over_scr    = ""
    genr_scr    = ""
    clas_scr    = ""
    race_scr    = ""
    defl_scr    = ""
    spec_scr    = ""
    cre_file    = ""
  BEGIN
      READ_LONG   0x54 actor_off
      READ_SHORT  0x58 actor_num
      WRITE_SHORT 0x58 ~%actor_num%~ + 1
      READ_LONG   0x5c triggers_off
      PATCH_IF (~%triggers_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x5c ~%triggers_off%~ + 0x110
      END
      READ_LONG   0x60 spawn_off
      PATCH_IF (~%spawn_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x60 ~%spawn_off%~ + 0x110
      END
      READ_LONG   0x68 entrance_off
      PATCH_IF (~%entrance_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x68 ~%entrance_off%~ + 0x110
      END
      READ_LONG   0x70 contain_off
      PATCH_IF (~%contain_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x70 ~%contain_off%~ + 0x110
      END
      READ_LONG   0x78 item_off
      PATCH_IF (~%item_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x78 ~%item_off%~ + 0x110
      END
      READ_LONG   0x7c vert_off
      PATCH_IF (~%vert_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x7c ~%vert_off%~ + 0x110
      END
      READ_LONG   0x84 ambi_off
      PATCH_IF (~%ambi_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x84 ~%ambi_off%~ + 0x110
      END
      READ_LONG   0x88 var_off
      PATCH_IF (~%var_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x88 ~%var_off%~ + 0x110
      END
      READ_LONG   0xa0 explore_off
      PATCH_IF (~%explore_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xa0 ~%explore_off%~ + 0x110
      END
      READ_LONG   0xa8 door_off
      PATCH_IF (~%door_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xa8 ~%door_off%~ + 0x110
      END
      READ_LONG   0xb0 anim_off
      PATCH_IF (~%anim_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xb0 ~%anim_off%~ + 0x110
      END
      READ_LONG   0xb8 tiled_off
      PATCH_IF (~%tiled_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xb8 ~%tiled_off%~ + 0x110
      END
      READ_LONG   0xbc song_off
      PATCH_IF (~%song_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xbc ~%song_off%~ + 0x110
      END
      READ_LONG   0xc0 rest_enc_off
      PATCH_IF (~%rest_enc_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xc0 ~%rest_enc_off%~ + 0x110
      END
      READ_LONG   0xc4 auto_map_off
      PATCH_IF (~%auto_map_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xc4 ~%auto_map_off%~ + 0x110
      END
      INSERT_BYTES ~%actor_off%~ 0x110
        WRITE_ASCIIE ~%actor_off%~ + 0x00 ~%actor_name%~ (32)
        WRITE_SHORT  ~%actor_off%~ + 0x20 ~%pos_x%~
        WRITE_SHORT  ~%actor_off%~ + 0x22 ~%pos_y%~
        WRITE_SHORT  ~%actor_off%~ + 0x24 ~%dest_x%~
        WRITE_SHORT  ~%actor_off%~ + 0x26 ~%dest_y%~
        WRITE_BYTE   ~%actor_off%~ + 0x28 ~%flags%~
        WRITE_LONG   ~%actor_off%~ + 0x30 ~%anim%~
        WRITE_SHORT  ~%actor_off%~ + 0x34 ~%dir%~
        WRITE_LONG   ~%actor_off%~ + 0x38 ~%expiri_time%~
        WRITE_SHORT  ~%actor_off%~ + 0x3c ~%wander_dist%~
        WRITE_SHORT  ~%actor_off%~ + 0x3e ~%follow_dist%~
        WRITE_LONG   ~%actor_off%~ + 0x40 ~%present_at%~
        WRITE_LONG   ~%actor_off%~ + 0x44 ~%talked_to%~
        WRITE_ASCIIE ~%actor_off%~ + 0x48 ~%dialogue%~ (8)
        WRITE_ASCIIE ~%actor_off%~ + 0x50 ~%over_scr%~ (8)
        WRITE_ASCIIE ~%actor_off%~ + 0x58 ~%genr_scr%~ (8)
        WRITE_ASCIIE ~%actor_off%~ + 0x60 ~%clas_scr%~ (8)
        WRITE_ASCIIE ~%actor_off%~ + 0x68 ~%race_scr%~ (8)
        WRITE_ASCIIE ~%actor_off%~ + 0x70 ~%defl_scr%~ (8)
        WRITE_ASCIIE ~%actor_off%~ + 0x78 ~%spec_scr%~ (8)
        WRITE_ASCIIE ~%actor_off%~ + 0x80 ~%cre_file%~ (8)
END
//BLOCKEND

//BLOCK ALTER_AREA_ACTOR_EX
DEFINE_PATCH_FUNCTION MATCH_ALTER_ACTOR
	INT_VAR
		match_pos_x = "-1"
		match_pos_y = "-1"
		match_dest_x = "-1"
		match_dest_y = "-1"
		match_bit_unattached = "-1"
		match_bit_has_seen = "-1"
		match_bit_invulnerable = "-1"
		match_bit_override_script = "-1"
		match_spawned = "-1"
		match_animation = "-1"
		match_orientation = "-1"
		match_expiry = "-2"
		match_wander = "-1"
		match_follow = "-1"
		match_talked_to = "-1"
		
		pos_x = "-1"
		pos_y = "-1"
		dest_x = "-1"
		dest_y = "-1"
		bit_unattached = 1
		bit_has_seen = 0
		bit_invulnerable = 0
		bit_override_script = 0
		spawned = "-1"
		animation = "-1"
		orientation = "-1"
		expiry = "-2"
		wander = "-1"
		follow = "-1"
		talked_to = "-1"
	STR_VAR
		match_name = "same"
		match_dialogue = "same"
		match_override_script = "same"
		match_general_script = "same"
		match_class_script = "same"
		match_race_script = "same"
		match_default_script = "same"
		match_specifics_script = "same"
		match_cre_file = "same"
		
		name = "same"
		dialogue = "same"
		override_script = "same"
		general_script = "same"
		class_script = "same"
		race_script = "same"
		default_script = "same"
		specifics_script = "same"
		cre_file = "same"
	RET
		file_txt
BEGIN
	SET minus_one = ( 0 - 1 )
	SET minus_two = ( 0 - 2 )
	SPRINT file_txt ~~
	READ_LONG  0x54 act_off
	READ_SHORT 0x58 act_num
	PATCH_IF ( act_num > 0 ) BEGIN
		FOR ( i = 0 ; i < act_num ; ++i ) BEGIN
			SET match = 0
			SET offset = act_off + i * 0x110
			READ_ASCII offset + 0x00 data ( 32 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_name%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_name%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_SHORT offset + 0x20 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_pos_x%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_pos_x%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_SHORT offset + 0x22 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_pos_y%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_pos_y%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_SHORT offset + 0x24 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_dest_x%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_dest_x%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_SHORT offset + 0x26 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_dest_y%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_dest_y%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_BYTE  offset + 0x28 flags
				LPF GET_BIT INT_VAR nth_bit = 0 number = flags RET data = bit_value END
				PATCH_IF ( match >= 0 ) AND ( ~%match_bit_unattached%~ != minus_one ) BEGIN
					PATCH_IF ( ~%match_bit_unattached%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
				END
				LPF GET_BIT INT_VAR nth_bit = 1 number = flags RET data = bit_value END
				PATCH_IF ( match >= 0 ) AND ( ~%match_bit_has_seen%~ != minus_one ) BEGIN
					PATCH_IF ( ~%match_bit_has_seen%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
				END
				LPF GET_BIT INT_VAR nth_bit = 2 number = flags RET data = bit_value END
				PATCH_IF ( match >= 0 ) AND ( ~%match_bit_invulnerable%~ != minus_one ) BEGIN
					PATCH_IF ( ~%match_bit_invulnerable%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
				END
				LPF GET_BIT INT_VAR nth_bit = 3 number = flags RET data = bit_value END
				PATCH_IF ( match >= 0 ) AND ( ~%match_bit_override_script%~ != minus_one ) BEGIN
					PATCH_IF ( ~%match_bit_override_script%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
				END
			READ_SHORT offset + 0x2c data
			PATCH_IF ( match >= 0 ) AND ( ~%match_spawned%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_spawned%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_LONG  offset + 0x30 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_animation%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_animation%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_SHORT offset + 0x34 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_orientation%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_orientation%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_LONG  offset + 0x38 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_expiry%~ != minus_two ) BEGIN
				PATCH_IF ( ~%match_expiry%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_SHORT offset + 0x3c data
			PATCH_IF ( match >= 0 ) AND ( ~%match_wander%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_wander%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_SHORT offset + 0x3e data
			PATCH_IF ( match >= 0 ) AND ( ~%match_follow%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_follow%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_LONG  offset + 0x44 data
			PATCH_IF ( match >= 0 ) AND ( ~%match_talked_to%~ != minus_one ) BEGIN
				PATCH_IF ( ~%match_talked_to%~ = ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x48 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_dialogue%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_dialogue%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x50 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_override_script%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_override_script%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x58 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_general_script%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_general_script%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x60 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_class_script%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_class_script%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x68 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_race_script%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_race_script%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x70 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_default_script%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_default_script%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x78 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_specifics_script%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_specifics_script%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			READ_ASCII offset + 0x80 data ( 8 ) NULL
			PATCH_IF ( match >= 0 ) AND ( ~%match_cre_file%~ STR_CMP ~same~ ) BEGIN
				PATCH_IF ( ~%match_cre_file%~ STR_EQ ~%data%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = minus_one END
			END
			PATCH_IF ( match = 1 ) BEGIN
				SET idx = i + 1
				SPRINT file_txt ~%file_txt%%idx%  %offset%  zzz%LNL%~
			END
		END
	END	
END

DEFINE_PATCH_FUNCTION ALTER_AREA_ACTOR_EX //0x110
	INT_VAR
		numbers = 2 //0 - first, 1 - last, 2 - all, 3 - position (start =  0)
		position = 10
		
		match_pos_x = "-1"
		match_pos_y = "-1"
		match_dest_x = "-1"
		match_dest_y = "-1"
		match_bit_unattached = "-1"
		match_bit_has_seen = "-1"
		match_bit_invulnerable = "-1"
		match_bit_override_script = "-1"
		match_spawned = "-1"
		match_animation = "-1"
		match_orientation = "-1"
		match_expiry = "-2"
		match_wander = "-1"
		match_follow = "-1"
		match_talked_to = "-1"
		
		pos_x = "-1"
		pos_y = "-1"
		dest_x = "-1"
		dest_y = "-1"
		bit_unattached = 1
		bit_has_seen = 0
		bit_invulnerable = 0
		bit_override_script = 0
		spawned = "-1"
		animation = "-1"
		orientation = "-1"
		expiry = "-2"
		wander = "-1"
		follow = "-1"
		talked_to = "-1"
	STR_VAR
		match_name = "same"
		match_dialogue = "same"
		match_override_script = "same"
		match_general_script = "same"
		match_class_script = "same"
		match_race_script = "same"
		match_default_script = "same"
		match_specifics_script = "same"
		match_cre_file = "same"
		
		name = "same"
		dialogue = "same"
		override_script = "same"
		general_script = "same"
		class_script = "same"
		race_script = "same"
		default_script = "same"
		specifics_script = "same"
		cre_file = "same"
BEGIN
	PATCH_IF ( numbers < 0 ) OR ( numbers > 3 ) BEGIN SET numbers = 2 END
	PATCH_IF ( numbers != 3 ) BEGIN SET position = ( 0 - 1 ) END
	LPF MATCH_ALTER_ACTOR
		INT_VAR match_pos_x match_pos_y match_dest_x match_dest_y match_bit_unattached match_bit_has_seen match_bit_invulnerable match_bit_override_script match_spawned match_animation match_orientation match_expiry match_wander match_follow match_talked_to pos_x pos_y dest_x dest_y bit_unattached bit_has_seen bit_invulnerable bit_override_script spawned animation orientation expiry wander follow talked_to
		STR_VAR match_name match_dialogue match_override_script match_general_script match_class_script match_race_script match_default_script match_specifics_script match_cre_file name dialogue override_script general_script class_script race_script default_script specifics_script cre_file
		RET file_txt
	END
	CLEAR_ARRAY num_items_array
	INNER_ACTION BEGIN
		OUTER_INNER_PATCH_SAVE ~file_txt~ ~%file_txt%~ BEGIN
			COUNT_2DA_ROWS 3 num_items
			FOR ( i = 0 ; i < num_items ; ++i ) BEGIN
				READ_2DA_ENTRY i 0 3 numx
				READ_2DA_ENTRY i 1 3 offset
				SET EVAL ~num_items_array_%i%~ = ~%offset%~
			END
		END
	END
	SET minus_one = ( 0 - 1 )
	SET minus_two = ( 0 - 2 )
	PATCH_IF ( num_items > 0 ) BEGIN
		PATCH_MATCH numbers WITH
			0 BEGIN
				SET num_items = 1
			END
			1 BEGIN
				SET idx = num_items - 1
				SET num_items = 1
				SET num_items_array_0 = EVAL ~num_items_array_%idx%~
			END
			2 BEGIN
			END
			3 BEGIN
				PATCH_IF ( position > num_items ) BEGIN SET position = num_items - 1 END
				SET num_items = 1
				SET num_items_array_0 = EVAL ~num_items_array_%position%~
			END
			DEFAULT
		END
		FOR ( i = 0 ; i < num_items ; ++i ) BEGIN
			SET offset = EVAL ~num_items_array_%i%~
			PATCH_IF ( ~%name%~             STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x00 ~%name%~ (32)            END
			PATCH_IF ( pos_x != minus_one )                  BEGIN WRITE_SHORT           offset + 0x20 pos_x                    END
			PATCH_IF ( pos_y != minus_one )                  BEGIN WRITE_SHORT           offset + 0x22 pos_y                    END
			PATCH_IF ( dest_x != minus_one )                 BEGIN WRITE_SHORT           offset + 0x24 dest_x                   END
			PATCH_IF ( dest_y != minus_one )                 BEGIN WRITE_SHORT           offset + 0x26 dest_y                   END
			READ_BYTE 0x28 flags
			//BLOCK 
			SET set_flags = flags
			PATCH_IF ( bit_unattached != minus_one ) BEGIN
				LPF GET_BIT INT_VAR nth_bit = 0 number = flags RET bit_value END
				PATCH_IF ( bit_value ) BEGIN
					PATCH_IF ( bit_unattached = 0 ) BEGIN SET set_flags = set_flags - 1       END
				END ELSE BEGIN
					PATCH_IF ( bit_unattached != 0 ) BEGIN SET set_flags = set_flags + 1      END
				END
			END
			PATCH_IF ( bit_has_seen != minus_one ) BEGIN
				LPF GET_BIT INT_VAR nth_bit = 1 number = flags RET bit_value END
				PATCH_IF ( bit_value ) BEGIN
					PATCH_IF ( bit_has_seen = 0 ) BEGIN SET set_flags = set_flags - 2         END
				END ELSE BEGIN
					PATCH_IF ( bit_has_seen != 0 ) BEGIN SET set_flags = set_flags + 2        END
				END
			END
			PATCH_IF ( bit_invulnerable != minus_one ) BEGIN
				LPF GET_BIT INT_VAR nth_bit = 2 number = flags RET bit_value END
				PATCH_IF ( bit_value ) BEGIN
					PATCH_IF ( bit_invulnerable = 0 ) BEGIN SET set_flags = set_flags - 4     END
				END ELSE BEGIN
					PATCH_IF ( bit_invulnerable != 0 ) BEGIN SET set_flags = set_flags + 4    END
				END
			END
			PATCH_IF ( bit_override_script != minus_one ) BEGIN
				LPF GET_BIT INT_VAR nth_bit = 3 number = flags RET bit_value END
				PATCH_IF ( bit_value ) BEGIN
					PATCH_IF ( bit_override_script = 0 ) BEGIN SET set_flags = set_flags - 8  END
				END ELSE BEGIN
					PATCH_IF ( bit_override_script != 0 ) BEGIN SET set_flags = set_flags + 8 END
				END
			END
			//BLOCKEND
			WRITE_BYTE 0x28 set_flags
			PATCH_IF ( spawned != minus_one )                BEGIN WRITE_SHORT           offset + 0x2c spawned                  END
			PATCH_IF ( animation != minus_one )              BEGIN WRITE_LONG            offset + 0x30 animation                END
			PATCH_IF ( orientation != minus_one )            BEGIN WRITE_SHORT           offset + 0x34 orientation              END
			PATCH_IF ( expiry != minus_two )                 BEGIN WRITE_LONG            offset + 0x38 expiry                   END
			PATCH_IF ( wander != minus_one )                 BEGIN WRITE_SHORT           offset + 0x3c wander                   END
			PATCH_IF ( follow != minus_one )                 BEGIN WRITE_SHORT           offset + 0x3e follow                   END
			PATCH_IF ( talked_to != minus_one )              BEGIN WRITE_LONG            offset + 0x44 talked_to                END
			PATCH_IF ( ~%dialogue%~         STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x48 ~%dialogue%~ (8)         END
			PATCH_IF ( ~%override_script%~  STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x50 ~%override_script%~ (8)  END
			PATCH_IF ( ~%general_script%~   STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x58 ~%general_script%~ (8)   END
			PATCH_IF ( ~%class_script%~     STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x60 ~%class_script%~ (8)     END
			PATCH_IF ( ~%race_script%~      STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x68 ~%race_script%~ (8)      END
			PATCH_IF ( ~%default_script%~   STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x70 ~%default_script%~ (8)   END
			PATCH_IF ( ~%specifics_script%~ STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x78 ~%specifics_script%~ (8) END
			PATCH_IF ( ~%cre_file%~         STR_CMP ~same~ ) BEGIN WRITE_EVALUATED_ASCII offset + 0x80 ~%cre_file%~ (8)         END
		END
	END
END
//BLOCKEND











